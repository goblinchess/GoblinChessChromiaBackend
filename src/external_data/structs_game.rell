

// Sent back to the client
struct in_game_result {
    game_rowid: integer;
    game_type: game_type;
    is_white: boolean;
    opponent_pubkey: pubkey;
    opponent_name: text;
    opponent_elo: integer;
    curr_turn_nr: integer; // If the game just started, this will be 0
    created_at: integer; // Unix timestamp
    seed_material: byte_array; // The base data used by the client to generate the seed (by signing this data and extract the seed from the signature.)
}

// Returned so that the client can see a list of old games
struct old_game_stat {
    game_rowid: integer; // To be able to find it later.
    created_at: integer; // Unix timestamp
    // Opponent data
    opponent_name: text; // Name of the opponent
    opponent_elo: integer;
    // My data
    new_elo_rating: integer;
    // Neutral data
    is_winner: boolean; // This player won
    is_draw: boolean; // No player won, it's a draw
    finish_reason: text; // Why the game ended
}



// Holding general game end info, specifically why the game ended.
struct game_end_data {
    is_finished: boolean; // True if this game is "finished", first step in ending the game. 
    is_my_claim: boolean;  // True if it was this player who finished the game (if "false" it was either the opponent who initiated the game ending or the node itself.)
    finish_reason: text; // Reason for ending the game.
    valid_seeds_count: integer; // Number of players who have successfully verified their seeds.
    invalid_seeds_count: integer; // Number of players who have bad seeds.
}
