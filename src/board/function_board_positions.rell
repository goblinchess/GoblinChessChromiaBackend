// All these "board_" functions work with the BOARD_POSITIONS_ALL struct.
// TODO: Could have made a namespace for this.

// ----------------
// Constructor
// ----------------

// Returns a BOARD_POSITIONS_ALL struct.
function board_positions_all_constructor(
    board_p: list<with_pos_and_alignment_and_type>, 
    board_o: list<with_pos_and_alignment_and_type>, 
    portal_list: list<portal_simple>,
    vuln_ctxt: pre_vuln_context? // Usually null
): board_positions_all {

    // 1. Pieces
    val pieces = map<integer, with_pos_and_alignment_and_type>();
    for (p in board_p) {
        pieces[p.pos] = p;
    }

    // 2. Obstacles
    val obstacles = map<integer, with_pos_and_alignment_and_type>();
    for (o in board_o) {
        obstacles[o.pos] = o;
    }

    // 3. Portals
    val portal_entry = map<integer, portal_simple>();
    val portal_exit = map<integer, portal_simple>();
    for (portal: portal_simple in portal_list) {
        portal_entry[portal.entry_pos] = portal; // Don't worry about two portals having the same entry, cannot happen
        portal_exit[portal.exit_pos] = portal; // Don't worry about two portals having the same exit, cannot happen
    }
  
    // 4. Vulnerable squares
    var board_vuln_map = map<integer, boolean>();
    if (vuln_ctxt != null and vuln_ctxt.prev_turn_vuln_path != null) {
        // Get the mid positions from the vulnerable path
        val mid_positions = path_get_mid_positions(vuln_ctxt.prev_turn_vuln_path);

        // Check if our position matches any of the mid positions
        // (For the pawn there will only even be one mid_pos, but we're over-engineering a bit here,
        // since in v2.0 there are plans for extended use.)
        for (mid_pos in mid_positions) {
            board_vuln_map[mid_pos] = true;
        }
    }

    // 5. Return the struct
    return board_positions_all(
        board_characters = pieces, 
        board_obstacles = obstacles,
        portals = portal_list,
        board_portal_entry = portal_entry,
        board_portal_exit = portal_exit,
        vuln_ctxt = vuln_ctxt,
        board_vuln_square = board_vuln_map
    );
}

// Use the new board pieces, keep the rest
function board_positions_all_clone_new_pieces(old_board: board_positions_all, new_board_piece_map: map<integer, with_pos_and_alignment_and_type>): board_positions_all {
    return board_positions_all(
        board_characters = new_board_piece_map, // The mock
        board_obstacles = old_board.board_obstacles,  // Sending the real thing, since we are not moving an obstacle
        portals = old_board.portals,
        board_portal_entry = old_board.board_portal_entry,
        board_portal_exit = old_board.board_portal_exit,
        vuln_ctxt = old_board.vuln_ctxt,
        board_vuln_square = old_board.board_vuln_square
    );
}

// Use the new board pieces, keep the rest
function board_positions_all_clone_new_obstacles(old_board: board_positions_all, new_board_obst_map: map<integer, with_pos_and_alignment_and_type>): board_positions_all {
    return board_positions_all(
        board_characters = old_board.board_characters, // Sending the real thing, since we are not moving a piece
        board_obstacles = new_board_obst_map,  // The mock
        portals = old_board.portals,
        board_portal_entry = old_board.board_portal_entry,
        board_portal_exit = old_board.board_portal_exit,
        vuln_ctxt = old_board.vuln_ctxt,
        board_vuln_square = old_board.board_vuln_square
    );
}

// ----------------
// Yes/No queries
// ----------------

function board_is_empty(board_positions_all, pos: integer): boolean {
    require(pos_is_on_board_int(pos), "Illegal position: " + pos);
    
    if (board_positions_all.board_characters.contains(pos)) {
        return false;
    }
    if (board_positions_all.board_obstacles.contains(pos)) {
        return false;
    }
    return true;
}

function board_is_free_at(board_positions_all, pos: square_pos): boolean {
    return board_get_square_status(board_positions_all, pos) == square_status.FREE;
}


function board_is_white_piece_at(board_positions_all, pos: square_pos): boolean {
    return board_get_square_status(board_positions_all, pos) == square_status.WHITE_PIECE;
}

function board_is_black_piece_at(board_positions_all, pos: square_pos): boolean {
    return board_get_square_status(board_positions_all, pos) == square_status.BLACK_PIECE;
}

function board_is_attackable_black_or_neutral_at(board_positions_all, pos: square_pos, can_attack_obstacle: boolean): boolean {
    val stat = board_get_square_status(board_positions_all, pos);
    if (stat == square_status.BLACK_PIECE or stat == square_status.NEUTRAL_PIECE) {
        return true;
    } else if (can_attack_obstacle) {
        return stat == square_status.OBSTACLE;
    } else {
        return false;
    }
}

function board_is_attackable_white_or_neutral_at(board_positions_all, pos: square_pos, can_attack_obstacle: boolean): boolean {
    val stat = board_get_square_status(board_positions_all, pos);
    if (stat == square_status.WHITE_PIECE or stat == square_status.NEUTRAL_PIECE) {
        return true;
    } else if (can_attack_obstacle) {
        return stat == square_status.OBSTACLE;
    } else {
        return false;
    }
}

// ----------------
// Getters
// ----------------
function board_get_at(board_positions_all, pos: integer): with_pos_and_alignment_and_type? {
    require(pos_is_on_board_int(pos), "Out of board " + pos);

    if (board_positions_all.board_characters.contains(pos)) {
        return board_positions_all.board_characters[pos];
    } else if (board_positions_all.board_obstacles.contains(pos)){
        return board_positions_all.board_obstacles[pos];
    } else {
        return null;
    }
}

function board_get_square_status(board_positions_all, pos: square_pos): square_status {
    if (pos_is_out_of_board(pos)) {
        return square_status.OUT_OF_BOARD;
    }
    val pos_int = pos_to_int(pos);
    return board_get_square_status_int(board_positions_all, pos_int);
}

function board_get_square_status_int(board_positions_all, pos: integer): square_status {
    if (pos_is_out_of_board_int(pos)) { 
        return square_status.OUT_OF_BOARD; // Should never happen, since we checked this in [board_get_square_status()]
    }
    
    if (board_positions_all.board_characters.contains(pos)) {
        val found = board_positions_all.board_characters[pos];
        return align_piece_to_square_status(found.alignment); // BLACK, WHITE or NEUTRAL
    } else if (board_positions_all.board_obstacles.contains(pos)){
        return square_status.OBSTACLE; // Easy
    } else {
        return square_status.FREE; // Easy
    }
}


// ----------------
// Mutators
// ----------------

// Moving a piece from one position to another
function board_place_character_at(
    board: board_positions_all,
    from_pos: integer,
    dest_pos: integer,
    attack_allowed: boolean
) {

    if (not attack_allowed) {
        // We MUST remove anything on the dest_pos before we do this.
        require(board_is_empty(board, dest_pos), "Destination position is not empty: " + dest_pos);
    }

    val old_piece: with_pos_and_alignment_and_type = board.board_characters[from_pos];
    val new_piece = with_pos_and_alignment_and_type(
        dest_pos, 
        old_piece.alignment, 
        old_piece.p_type, 
        is_knighted = old_piece.is_knighted, 
        is_obstacle = old_piece.is_obstacle);

    board.board_characters.remove(from_pos);
    board.board_characters[dest_pos] = new_piece;
}

// A piece (magically) appears on the board.
// If you are MOVING a piece, use board_place_character_at() instead.
function board_appear_at(
    board: board_positions_all,
    piece_pos: integer,
    piece_align: alignment,
    p_type: piece_type,
    is_knighted: boolean,
    is_obstacle: boolean
) {
    require(not board.board_characters.contains(piece_pos), "board_appear_at() - ERROR: Position is already occupied: " + piece_pos);

    val new_piece = with_pos_and_alignment_and_type(piece_pos, piece_align, p_type, is_knighted, is_obstacle);

    board.board_characters[piece_pos] = new_piece;
}

// Whatever is on the given position, remove it.
function board_remove_at(
    board: board_positions_all,
    pos: integer
) {
    require(not board_is_empty(board, pos), "Destination position is not empty: " + pos);

    if (board.board_characters.contains(pos)) {
        board.board_characters.remove(pos);
    } else if (board.board_obstacles.contains(pos)) {
        board.board_obstacles.remove(pos);
    } else {
        require(false, "Internal error: we already checked the board.");
    }
}

