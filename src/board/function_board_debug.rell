

function board_debug_print(game_id: integer, last_rot_nr: integer, board_all: board_positions_all): text {
    var out = "\n";

    out += "+---------------------------+\n";
    out += "|Game: " + game_id + " (r: " + last_rot_nr + ")\n";
    out += "+---------------------------+\n";
    for (rev_y in range(0, 8)) {
        val y = 7 - rev_y;
        val rank = y + 1;
        out += "|" + rank + "= ";
        for (x in range(0, 8)) {
            val pos_sq = square_pos(x, y);
            val pos: integer = pos_to_int(pos_sq);
            out += board_debug_object(board_all, pos) + " ";
        }
        out += "|\n";
    }
    out += "+---------------------------+\n";
    out += "|   a  b  c  d  e  f  g  h  |\n";
    out += "+---------------------------+";
    return out;
}

function board_debug_object(board_all: board_positions_all, pos: integer): text {
    if (board_all.board_characters.contains(pos)) {
        val piece = board_all.board_characters[pos];
        return align_wpat_to_code(piece, false, false); // Don't care about check here
    } else if (board_all.board_obstacles.contains(pos)) {
        return "O ";
    } else if (board_all.board_vuln_square.contains(pos)) {
        return "* "; // Somewhat unclear if this is good to display, but since en passant is so hard it might be good to show it when we can.
    } else if (board_all.board_portal_entry.contains(pos)) {
        // We only show portal entry if the square is empty
        val portal = board_all.board_portal_entry[pos];
        if (portal.owner_alignment == alignment.WHITE) {
            return "1>";
        } else {
            return "2>";
        }
    } else if (board_all.board_portal_exit.contains(pos)) {
        // We only show portal exit if the square is empty
        val portal = board_all.board_portal_exit[pos];
        if (portal.owner_alignment == alignment.WHITE) {
            return "<1";
        } else {
            return "<2";
        }
    } else {
        return ". "; // Empty
    }

}