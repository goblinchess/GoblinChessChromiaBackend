


// ---------------------------------------------------------------------
// Returns the entire board as a compact text string. 
// 
// Note:
// This format is not ideal for showing a human, but is good enought to store in the DB.
// This should contain the same info as the debug version, so that we could
// send these strings to the client, and it should be able to display the board
// in some primitive manner.
// This format is very destructive! For example: If a piece is standing on a portal entry or exit
// this will remove the portal so that only the piece will be visible.
// ---------------------------------------------------------------------
function board_compress(game_id: integer, board_all: board_positions_all): text {
    var out = "";

    for (pos in range(0, 64)) {
        val obj = board_compress_object(board_all, pos);
        if (obj.size() > 0) { // We only store squares with something on them.
            out += pos + ":" + obj + ","; // Gotta store the square nr.
        }
    }
    return out;
}

// We're using the same characters as when debugging.
function board_compress_object(board_all: board_positions_all, pos: integer): text {
    var out = "";
    if (board_all.board_characters.contains(pos)) {
        val piece = board_all.board_characters[pos];
        out += align_wpat_to_code(piece).trim();
    } else if (board_all.board_obstacles.contains(pos)) {
        out += "O";
    }

    // We don't have the requirement that we max must have two characters per square.
    if (board_all.board_vuln_square.contains(pos)) {
        out += "*"; // Somewhat unclear if this is good to save, but the client can choose to ignore this one on the board if it doesn't want it.
    } 
    
    if (board_all.board_portal_entry.contains(pos)) {
        // We only show portal entry if the square is empty
        val portal = board_all.board_portal_entry[pos];
        if (portal.owner_alignment == alignment.WHITE) {
            out += "->";
        } else {
            out += "=>";
        }
    } 
    if (board_all.board_portal_exit.contains(pos)) {
        // We only show portal exit if the square is empty
        val portal = board_all.board_portal_exit[pos];
        if (portal.owner_alignment == alignment.WHITE) {
            out += "<-";
        } else {
            out += "<=";
        }
    }
    
    return out;
}