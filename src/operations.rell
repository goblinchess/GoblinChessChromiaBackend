// -------------------------------------
// Player
// -------------------------------------

// Create a new player with the given name and signer
operation create_player(name: text) {
    // Check if name is valid
    require(name.size() > 0, "Player name cannot be empty");
    require(name.size() <= 30, "Player name too long (max 30 characters)");

    val existing_name = player@? {.name == name};
    require(existing_name == null, "Player name already exists");

    val current_signers = op_context.get_signers();
    val signer = current_signers[0];
    val existing_signer = player@? {.signer == signer};
    require (existing_signer == null, "Player public key already exists");


    // Create new player with default values
    create player(
        .signer = signer,
        .name = name,
        .games_played = 0,
        .games_won = 0,
        .games_lost = 0,
        .games_drawn = 0,
        .elo_rating = 1200 // Standard starting ELO rating
    );
} 


// -------------------------------------
// Lobby 
// -------------------------------------

operation enter_lobby(game_type_str: text) {

    val current_signers = op_context.get_signers();
    val current_signer = current_signers[0];
     
    val playa = player@ {.signer == current_signer};

    val g_type = game_type.value(game_type_str);

    val existing_lobby = lobby@? {.player == playa, .game_type == g_type};

    if (existing_lobby == null) {

        create lobby(
        .player = playa,
        .game_type = g_type,
        .last_heartbeat = op_context.last_block_time
        );
    }
    else {
        update existing_lobby (.last_heartbeat = op_context.last_block_time);
    }
}

// -------------------------------------
// Game
// -------------------------------------

operation create_game_via_lobby_by_name(opp_player_name: text, game_type_str: text) {
    val opponent_player = player@{.name == opp_player_name};
    create_game_via_lobby_inner(opponent_player, game_type_str);
}

operation create_game_via_lobby(opp_player: pubkey, game_type_str: text) {
    val opponent_player = player@{.signer == opp_player};
    create_game_via_lobby_inner(opponent_player, game_type_str);
}

function create_game_via_lobby_inner(opponent_player: player, game_type_str: text) {
    val current_signers = op_context.get_signers();
    val caller_pubkey = current_signers[0];
    
    // Get this player entity
    val caller_player = player@{.signer == caller_pubkey};

    val g_type = game_type.value(game_type_str);
    val existing_lobby = lobby@? {.player == opponent_player, .game_type == g_type};
    require(existing_lobby != null, "Opponent is not in the lobby");
    
    create_game_random_black_white(caller_player, opponent_player, game_type_str);

    // Remove opponent's lobby
    delete lobby@* {.player == opponent_player};
    // Remove caller's lobby
    delete lobby@* {.player == caller_player};
}

function create_game_random_black_white(caller_player: player, opponent_player: player, game_type_str: text) {
    // Determine who plays white based on timestamp
    val timestamp_is_even = (op_context.last_block_time / 1000) % 2 == 0;
    
    // If timestamp is even, opponent plays white. If odd, caller plays white
    val (white_player, black_player) = if (timestamp_is_even) 
        (opponent_player, caller_player)
     else 
        (caller_player, opponent_player);
    
    create_game_inner(white_player, black_player, game_type_str);
}

// Create a new game between two players

operation create_game(white_player_name: text, black_player_name: text, game_type_str: text) {
    require(white_player_name != black_player_name, "Players must be different");
    
    val white_player = player@{white_player_name};
    val black_player = player@{black_player_name};

    create_game_inner(white_player, black_player, game_type_str);
}


// We create the GAME and 
// one HAND for each player
function create_game_inner(white_player: player, black_player: player, game_type_str: text) {

    val g_type: game_type = game_type.value(game_type_str);
    
    val new_game =create game(
        .white_player = white_player,
        .black_player = black_player,
        .game_type = g_type,
        .current_turn = 0,
        .is_finished = false, 
        .is_draw = false,
        .created_at = op_context.last_block_time
    );

    // Create white player_game
    val white_player_game = create player_game(
        .player = white_player,
        .game = new_game,
        .is_white = true,
        .is_finished = false,
        .cards_left = 5
    );

    // Create black player_game
    val black_player_game = create player_game(
        .player = black_player,
        .game = new_game,
        .is_white = false,
        .is_finished = false,
        .cards_left = 5
    );

    // Create 16 pieces for each player
    piece_create_all(new_game, white_player_game, black_player_game);

    /*
    // Generate 10 random card ids (card id = 0-9)
    val random_card_numbers = generate_random_numbers(op_context.last_block_time, 10, 9);

    // Add 5 cards to the white hand
    for (i in range(5)) {  // <- 0-4
        val card_id = random_card_numbers[i];
        val card_type = card_type.value(card_id);
        create card(
            .hand = white_hand,
            .card_type = card_type,
            .is_used = false
        );
    }

    // Add 5 cards to the black hand
    for (j in range(5)) {

        val i = j + 5;
        val card_id = random_card_numbers[i];
        val card_type = card_type.value(card_id);
        create card(
            .hand = black_hand,
            .card_type = card_type,
            .is_used = false
        );

    }
    */
}

