

// -------------------------------------
// A function is easier to test. 
// -------------------------------------
function card_play_inner(
    caller_pubkey: pubkey,
    game_id: integer, 
    last_seen_turn: integer, // What turn the client last saw.
    card_type_str: text, 
    card_order_number: integer, // The order number when the card was drawn/generated.
    card_picks: list<integer>, // The squares picked by the player when playing the card.
    rnd_numbers: list<rnd_data>, // If any randomness was used playing this card, the numbers generated goes in here.

    // ----------------------
    // Only if the client needs to send it
    // ---------------------- 
    check_args: move_check_arguments? = null // Yes, a card can result in check/mate.
) {
    // -----------    
    // A. Verication
    // -----------    
    log("Play Card Beign, game: " + game_id + ", last turn: " + last_seen_turn + ", type: " + card_type_str + ", order number: " + card_order_number );

    // A.1. Check player entity
    val minimal_game: minimal_game_result? = get_minimal_game_data(caller_pubkey);
    require (minimal_game != null, "Player is not in a game");

    var new_turn_type = turn_type.BLACK_CARD;
    var my_color = alignment.BLACK;
    var opp_color: alignment = alignment.WHITE;
    if (minimal_game.is_white) { 
        new_turn_type = turn_type.WHITE_CARD;
        my_color = alignment.WHITE;
        opp_color = alignment.BLACK; 
    }
    
    // Yeah, but is it the CORRECT game?
    val found_game_rowid = minimal_game.game.rowid.to_integer();
    require (found_game_rowid == game_id, "Player things the game is " + game_id + " but is currently in game " + found_game_rowid);

    // A.2. Is game is out of sync? 
    val curr_turn = minimal_game.curr_turn_nr;
    require(curr_turn == last_seen_turn, "Player client is on turn " + last_seen_turn + " but blockchain is on turn " + curr_turn);
    
    // A.3. Check card type
    val card_type: card_type = card_type.value(card_type_str);

    // A.4. Check if player has cards left
    val cards_left = minimal_game.player_game.cards_left;
    require(cards_left > 0, "How can this player play a card when they have no cards left?");
    
    // A.5. Check if correct number of picks are sent for this card
    val expected_pick_types: list<card_pick_type> = card_pick_get_by_card_type(card_type); 
    val expected_nr_of_picks = expected_pick_types.size();
    require(expected_nr_of_picks == card_picks.size(), "Expected " + expected_nr_of_picks + " picks for card " + card_type_str + " but got " + card_picks.size());

    // -----------    
    // B. Updates Maybe
    // -----------    
    // B.1. Create the turn record
    // Do this FIRST since lots of verification in here.
    val new_turn = turn_create(minimal_game.game, minimal_game.player_game, new_turn_type, minimal_game.is_white);

    // B.2 Maybe Revert Enchantments
    // We need to revert enchantments before we can verify the picks, since if a STONE times out (becomes a piece again)
    // it should be allowed to be picked for a new spell.
    card_enchantment_revert_timed_out(minimal_game.game, minimal_game.player_game, new_turn);

    // -----------    
    // A. Verication, cont
    // -----------    

    // We need the full board
    val board: list<with_pos_and_alignment> = vuln_get_all_as_wpaa(minimal_game.game); 
    val portals: list<owned_portal> = move_get_all_portals(minimal_game.player_game, my_color);
    val board_positions_all = board_positions_all_constructor(minimal_game.game, board, portals);

    // A.6. Check individual picks 
    val pick_piece_map = map<integer, piece_living_data>(); // Save the pieces we found on the board for the pick.
    val pick_summary = card_pick_are_valid(minimal_game.game, card_type, card_type_str, expected_pick_types, card_picks, my_color, pick_piece_map);

    log("Card passed verification, game: " + game_id +", type: " + card_type_str + " order number: " + card_order_number + " picks: " + pick_summary);

    // -----------    
    // B. Updates, cont
    // -----------    
    // We must replicate the random number used on the client side.
    val rnd_list = list<rnd_result>();

    // B.3. We create the card when it's played
    val new_card =create card(minimal_game.player_game, new_turn, card_type, card_order_number);

    // B.4. Count down the cards left
    update minimal_game.player_game (.cards_left = cards_left - 1);

    // B.5. Create the picks
    for (i: integer in range(expected_pick_types.size())) {
        val expected_p_type: card_pick_type = expected_pick_types[i];
        val given_pos: integer = card_picks[i];

        val is_piece = pick_piece_map.contains(given_pos);
        val card_pick = create card_pick(
            .picked_square = given_pos, 
            .card = new_card, 
            .order_number = i, 
            .is_piece = is_piece
        );

        if (is_piece) {
            val piece = pick_piece_map[given_pos];
            // To connect the card pick to the piece that was picked.
            create card_pick_piece(card_pick, piece.p);
        }
    }

    // -----------    
    // B.6. Implement the effect of the card
    // -----------    
    // Card pick verification should have been done already.
    when (card_type) {
        // ----------------
        // a) Enchantments (no change in position or alignment, so no update of [board_positions_all])
        // ----------------
        FROG -> {
            card_enchantment_create_frog(minimal_game.game, new_turn, minimal_game.player_game, new_card, pick_piece_map[0]);
        }
        TURN_TO_STONE -> {
            card_enchantment_create_stone(minimal_game.game, new_turn, minimal_game.player_game, new_card, pick_piece_map[0]);
        }
        POTION -> {
            card_enchantment_create_potion(minimal_game.game, new_turn, new_card, pick_piece_map[0]);
        }
        KNIGHTED -> {
            card_enchantment_create_knighted(minimal_game.game, new_turn, new_card, pick_piece_map[0]);
        }
        JUMP -> {
            card_enchantment_create_jump(minimal_game.player_game, new_card, pick_piece_map[0]);
        }
        // ----------------
        // b) Something happens on the Board 
        // ----------------
        SWITCH_PLACE -> {
            card_board_change_create_switch_place(my_color, new_card, pick_piece_map[0], pick_piece_map[1]);
            // Actually, since both pieces have the same alignment, the switch won't effect the [board_positions_all].
        }
        WALL -> {
            card_board_change_create_wall(minimal_game.game, minimal_game.player_game, new_card, pick_piece_map, card_picks, board_positions_all);
        }
        PORTAL -> {
            // Portal needs a random number
            require(rnd_numbers.size() == 1, "Portal needs one random number used when the exit is calculated.");
            val rnd_data = rnd_numbers[0];

            val portal_entry_pos = card_picks[0];
            val portal_exit_pos = card_picks[1]; // Strictly not a pick, but we do it this way.

            card_board_change_create_portal(minimal_game.player_game, new_card, pick_piece_map, portal_entry_pos, portal_exit_pos, rnd_data, new_turn, board_positions_all);
        }
        // ----------------
        // c) Delayed effects (no update of [board_positions_all])
        // ----------------
        RESURRECT -> {

            // Note: the random number is used when the actual resurrection happens.
            create_potential_resurrect(minimal_game.player_game, new_card);
        }
        DOUBLE_MOVE -> {
            create_double_move(minimal_game.player_game, new_card);
        }
    }

    // Get all pieces of both teams
    // Expensive, so we wait until last moment
    val our_team = team_build_from_db(minimal_game.game, my_color);
    val opp_team = team_build_from_db(minimal_game.game, opp_color);

    val our_king = team_get_king(our_team)!!;
    val opp_king = team_get_king(opp_team)!!;

    // B.7 Verify if we just won via checkmate?
    val (is_check, is_checkmate, is_stalemate) = check_stale_n_mate(minimal_game, board_positions_all, opp_color, opp_king, our_team, opp_team, check_args);
    val is_game_over = game_over(minimal_game, new_turn, is_checkmate, is_stalemate);

    // B.7. Move to next turn
    log("/Play Card End, game: " + game_id + ", new turn type: " + new_turn_type + ", type: " + card_type_str + ", order number: " 
            + card_order_number + ", picks: " + pick_summary + ", is_game_over: " + is_game_over);
}



