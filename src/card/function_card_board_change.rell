
// ------------------------------------------------------------
// Public functions
// ------------------------------------------------------------
// These spells cause an immediate change on the board. 
// ------------------------------------------------------------


// 6. SWITCH_PLACE
function card_board_change_create_switch_place(align: alignment, new_card: card, picked_piece1: piece_living_data, picked_piece2: piece_living_data) {
    alive_switch_place(align, picked_piece1.vuln.a, picked_piece2.vuln.a); // Piece function
}

// 7. WALL
function card_board_change_create_wall(
    game: game, 
    owner: player_game, 
    new_card: card, 
    pick_piece_map: map<integer, piece_living_data>, 
    card_picks: list<integer>, 
    board_positions_all
) {

    val sq1 = card_picks[0];
    val sq2 = card_picks[1];
    val sq3 = card_picks[2];

    // Validation
    // Must create a wall on empty squares
    // But didn't we validate this already when verifying the picks?
    require(board_get_at(board_positions_all, sq1) == null, "Wall position " + sq1 + " is occupied by a piece");
    require(board_get_at(board_positions_all, sq2) == null, "Wall position " + sq2 + " is occupied by a piece");
    require(board_get_at(board_positions_all, sq3) == null, "Wall position " + sq3 + " is occupied by a piece");

    vuln_setup_wall(game, owner, sq1, sq2, sq3); // Vuln function

    // Update the board
    board_positions_all.board_obstacles[sq1] = with_pos_and_alignment(sq1, alignment.NEUTRAL);
    board_positions_all.board_obstacles[sq2] = with_pos_and_alignment(sq2, alignment.NEUTRAL);
    board_positions_all.board_obstacles[sq3] = with_pos_and_alignment(sq3, alignment.NEUTRAL);
}

// 8. PORTAL
// We ONLY have to create the portal here, the piece will travel through it on the next turn.
function card_board_change_create_portal(
    owned_by: player_game, 
    new_card: card, 
    pick_piece_map: map<integer, piece_living_data>, 
    portal_entry_pos: integer, 
    portal_exit_pos: integer,
    rnd_data: rnd_data,
    new_turn: turn,
    board_positions_all
) {

    // Player is allowed  to create a tunnel from either side of the board,
    // We should figure out what side the exit is on.
    val exit_side_color = card_portal_get_other_side(portal_entry_pos);

    // Verify if the given portal exit is a suitable empty square on the board
    // And if so, save the random number that corresponds to it.
    val rnd_res = card_portal_verify_random_free_square_anywhere_on_half(
                board_positions_all,
                exit_side_color,
                portal_exit_pos,
                rnd_data
    );

    // A. Validation
    // Must create a portal on a square with a piece on it.
    require(pick_piece_map.contains(0), "Portal entry " + portal_entry_pos + " is not occupied by a piece");

    // B. Updates
    move_setup_portal(owned_by, new_card, portal_entry_pos, portal_exit_pos);

    val rnd_results: list<rnd_result> = [rnd_res]; // Only one element
    rnd_validation_create_player_rnd_nr(new_turn, rnd_results);
}