


// Fetch everything from the card that was played the given turn and return it.
function card_played_data_get(turn: turn, turn_type: turn_type, turn_nr: integer): card_played_data {
    
    // Find the card played during this turn
    val card_res = (c: card) @ { c.turn == turn } 
        (c.card_type, c.draw_order_nr, crd = c);
    
    // Get all picks for this card, ordered by order_number
    val picks: list<integer> = (cp: card_pick) @* {
        cp.card == card_res.crd
    } (cp.picked_square, @omit @sort cp.order_number); 
    
    // Return the complete card played data
    return card_played_data(
        card_type_str = card_res.card_type.name,
        card_order_number = card_res.draw_order_nr,
        card_picks = picks 
    );
}

// Fetch all cards played for the given game, and fetch everything from the card that was played.
// Return the map from turn_nr -> the card data.
// Don't worry about two cards being played the same turn, that cannot happen.
function card_played_data_get_all(game_id: integer, gme: game): map<integer, card_played_data> {

    // Fetch ALL picks in one go, it's faster
    val picks_all = (c: card, t: turn, cp: card_pick) @* {
            t.game == gme,
            c.turn == t,
            cp.card == c
    } (cp.picked_square, cp.order_number, crd = c, turn_nr = t.number); 

    // Sort the picks in a map
    val turn_to_pick_map: map<card, map<integer, integer>> = map<card, map<integer, integer>>();
    for (pick in picks_all) {
        val crd = pick.crd;
        if (turn_to_pick_map.contains(crd)) {
            val inner_map: map<integer, integer> = turn_to_pick_map.get(crd);
            inner_map[pick.order_number] = pick.picked_square;
        } else {
            val inner_map: map<integer, integer> = map<integer, integer>();
            inner_map[pick.order_number] = pick.picked_square;
            turn_to_pick_map.put(crd, inner_map);
        }
    }
     
    // Find all cards played during this game by joining through turn
    val cards_res = (c: card, t: turn) @* { 
        t.game == gme,
        c.turn == t
    } (c.card_type, c.draw_order_nr, crd = c, c.turn, turn_nr = t.number);

    // For each card, get all picks ordered by order_number
    val result: map<integer, card_played_data> = map<integer, card_played_data>();
    for (card_data in cards_res) {

        val picks: list<integer> = [];
        if (turn_to_pick_map.contains(card_data.crd)) { // Not all cards have any picks
            val inner_map: map<integer, integer> = turn_to_pick_map.get(card_data.crd);

            // It's not super important that we get the picks in the right order,
            // since we're not USING the picks, just showing them (all at once)
            // but you never know how this data will be used, so by just looping 
            // through the [inner_map] we'll get them in order.
            for (pick_order_nr in inner_map.keys()) {
                picks.add(inner_map.get(pick_order_nr));
            }
        }

        val c_data = card_played_data(
            card_type_str = card_data.card_type.name,
            card_order_number = card_data.draw_order_nr,
            card_picks = picks 
        );

        result[card_data.turn_nr] =  c_data;
    }

    log("game_id: " + game_id + " - Found " + result.size() + " cards");
    
    return result;
}