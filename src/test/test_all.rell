@test module;

import ^^.*; // Import all the things from parent folder 
import ^^.card.*;
import ^^.piece.*;
import ^^.move.*;
import ^^.turn.*;

function test_move_encode_decode() {
    val positions = [7, 16, 62];
    val enc_path = move_encode_int_pos_list(positions);
    val decoded_positions = move_dencode_text_pos_list(enc_path);

    assert_equals(positions, decoded_positions);
}

// ----------------------------------
// Random
// ----------------------------------

function test_random_new_numbers_list() {
    val rnd_results: list<rnd_result> = [
        rnd_result(result = 1, min = 1, max = 6),
        rnd_result(result = 2, min = 1, max = 6),
        rnd_result(result = 3, min = 1, max = 6)
    ];
    val rnd_numbers: list<integer> = [1, 2, 3, 4, 5, 6];
    val new_rnd_numbers = random_new_numbers_list(rnd_results, rnd_numbers);
    assert_equals(new_rnd_numbers, [4, 5, 6]);
}

// ----------------------------------
// Battle 
// ----------------------------------

// Setup a case where the defender has a strong defence,
// so we might provoke retaliation.
function test_battle_strong_defence() {
    val can_retaliate = true;
    val flash_attack = false; 
    val chaos_args = move_chaos_mode_arguments(
        defender_can_retaliate = can_retaliate,
        is_flash_attack = flash_attack,
        is_luck = false
    );

    val def_hp = 10;
    val def_defense = 4;
    val def_strength = die_set_get_default_chaotic(); 

    val att_hp = 4;
    val att_defense = 1;
    val att_strength = die_set_get_default_chaotic();

    // ----------------
    log("Test 1: rnd = 1+3, expect Hit with 4 damage, retaliation Miss");
    // ----------------
    var br = calculate_chaos_attack_result(
        def_hp, def_strength, def_defense,
        att_hp, att_strength, att_defense,
        chaos_args,
        [1, 3, 2] // NOTE: one extra due to "miss" calculation
    );

    // Attack failed
    assert_equals(br.result, battle_result_type.MISS);
    assert_equals(br.defender_lost_hp, 0); // 4 - 4 = 0
    // Retaliation failed
    assert_equals(br.retaliation_result, battle_result_type.ERROR);
    assert_equals(br.attacker_lost_hp, 0);

    // ----------------
    log("Test 2: rnd = 2,3,2,2 expect hit with 5 damage.");
    // ----------------
    br = calculate_chaos_attack_result(
        def_hp, def_strength, def_defense,
        att_hp, att_strength, att_defense,
        chaos_args,
        [2,3,2,2]
    );
    // Attack success
    assert_equals(br.result, battle_result_type.HIT);
    assert_equals(br.defender_lost_hp, 1); // 5 -4 = 1
    // Retaliation fails
    assert_equals(br.retaliation_result, battle_result_type.MISS); // 4 - 1 +(-7) = -4
    assert_equals(br.attacker_lost_hp, 0);

    // ----------------
    log("Test 3: rnd = 2,6,5,6 expect Hit with 8 damage, retaliation hit");
    // ----------------
    br = calculate_chaos_attack_result(
        def_hp, def_strength, def_defense,
        att_hp, att_strength, att_defense,
        chaos_args,
        [2,6,5,6]
    );
    // Attack success
    assert_equals(br.result, battle_result_type.HIT);
    assert_equals(br.defender_lost_hp, 4); // 8 -4 = 4
    assert_equals(br.retaliation_result, battle_result_type.HIT);
    assert_equals(br.attacker_lost_hp, 3); // 11 - 1 +(-7) = 3

    // ----------------
    log("Test 4: rnd = 3,6,6,6 expect Hit with 9 damage, retaliation kill");
    // ----------------
    br = calculate_chaos_attack_result(
        def_hp, def_strength, def_defense,
        att_hp, att_strength, att_defense,
        chaos_args,
        [3,6,6,6]
    );
    // Attack success
    assert_equals(br.result, battle_result_type.HIT);
    assert_equals(br.defender_lost_hp, 5); // 9 -4 = 5
    assert_equals(br.retaliation_result, battle_result_type.KILL); // 12 - 1 +(-7) = 4
}

// ----------------------------------
// ELO
// ----------------------------------
function test_elo_draw_1() {

   val player1_rating: integer = 1200;
   val player2_rating: integer = 1200;

    val (p1: integer, p2: integer) = elo.update_chess_ratings_on_draw(
        player1_rating,
        player2_rating
    );

    assert_equals(p1, 1200);
    assert_equals(p2, 1200);
}

function test_elo_draw_2() {

   val player1_rating: integer = 1300;
   val player2_rating: integer = 1200;

    val (p1: integer, p2: integer) = elo.update_chess_ratings_on_draw(
        player1_rating,
        player2_rating
    );

    assert_equals(p1, 1296);
    assert_equals(p2, 1204);
}


function test_elo_win_1() {

   val player1_rating: integer = 1200;
   val player2_rating: integer = 1200;

    val (p1: integer, p2: integer) = elo.update_chess_ratings_on_win(
        player1_rating,
        player2_rating,
	    true
    );

    assert_equals(p1, 1216);
    assert_equals(p2, 1184);
}

function test_elo_win_2() {
   val player1_rating: integer = 1300;
   val player2_rating: integer = 1200;

    val (p1: integer, p2: integer) = elo.update_chess_ratings_on_win(
        player1_rating,
        player2_rating,
        false
    );

    assert_equals(p1, 1280);
    assert_equals(p2, 1220);
}

// ----------------------------------
// Power Of 
// ----------------------------------

// Basic math thes
function test_ten_to_the_power_of() {
    val x = 1.0;
    val result = ten_to_the_power_of(x);
    log("10 ^ 1=" + result.to_text());
    assert_true(result < 10.001);
    assert_true(result > 9.999);
    
    val x2 = 2.0;
    val result2 = ten_to_the_power_of(x2);
    log("10 ^ 2=" + result2.to_text());
    assert_true(result2 < 100.001);
    assert_true(result2 > 99.999);
}


// ----------------------------------
// Game
// ----------------------------------

function test_full_game() {

    // ------------
    // Check if DB is empty
    // ------------
    val players: list<rowid> = player@* {} (.rowid);
    assert_equals(players.size(), 0);


    // ------------
    log("Create the players");
    // ------------
     
    // All in one
    rell.test.tx(create_player("Alice")).sign(rell.test.keypairs.alice).run();
    rell.test.tx(create_player("Bob")).sign(rell.test.keypairs.bob).run();
    rell.test.tx(create_player("Charlie")).sign(rell.test.keypairs.charlie).run();
    rell.test.tx(create_player("Dave")).sign(rell.test.keypairs.dave).run();

    // ------------
    log("Check if players are created");
    // ------------
    val players_after: list<rowid> = player@* {} (.rowid);
    assert_equals(players_after.size(), 4);


    rell.test.tx(enter_lobby("SPEED_5_CLASSIC")).sign(rell.test.keypairs.bob).run();
    rell.test.tx(enter_lobby("SPEED_10_CLASSIC")).sign(rell.test.keypairs.charlie).run();
    rell.test.tx(enter_lobby("SPEED_5_CLASSIC")).sign(rell.test.keypairs.dave).run();

    // Alice looks for 10 min match
    val match_10_mins = consume_lobby_entry(rell.test.keypairs.alice.pub, 0, "SPEED_10_CLASSIC");
    // ALice finds Charlie
    val opp_player: pubkey = rell.test.keypairs.charlie.pub;
    assert_equals(match_10_mins, opp_player);

    // ------------
    log("Alice creates a 10 min game with Charlie");
    // ------------
    rell.test.tx(create_game_via_lobby(opp_player, "SPEED_10_CLASSIC")).sign(rell.test.keypairs.alice).run();

    // ------------
    log("Alice looks for the game");
    // ------------
    val found_game: in_game_result? = in_game(rell.test.keypairs.alice.pub);
    assert_not_null(found_game);
    val the_game = found_game;
    val alice_white = the_game.is_white;
    var alice_color = "black";
    var white_player = rell.test.keypairs.charlie;
    var black_player = rell.test.keypairs.alice;
    if (alice_white) {
        alice_color = "white";
        white_player = rell.test.keypairs.alice;
        black_player = rell.test.keypairs.charlie;
    }


    assert_equals(the_game.game_type, game_type.SPEED_10_CLASSIC);
    assert_equals(the_game.opponent_pubkey, opp_player);
    assert_equals(the_game.opponent_name, "Charlie");
    assert_equals(the_game.opponent_elo, 1200);
    assert_equals(the_game.curr_turn_nr, 0);

    // ------------
    log("New Game: Verify pieces");
    // ------------
    val pieces = get_my_living_pieces(the_game.game_rowid, true);
    assert_equals(pieces.size(), 16);
    var out_str = alice_color + " pieces: ";
    for (p in pieces) {
        assert_true(p.is_alive);
        assert_equals(p.color_str,"white");
        assert_true(p.active_type_str == p.original_type_str);
        out_str += p.active_type_str + "=" + p.position + "("+ p.remaining_hit_points + "), ";
    }

    log(out_str);

    var last_seen_turn = 0;

    // +++++++++++++++++++++++++++++++++++++++++ White Move 1 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // --------------------
    // Failed White Cards
    // --------------------
    // First we try a few invalid cards, to make sure the validation works.

    log("Turn 1: Card Fail A. No picks for FROG");
    val card_picks_none: list<integer> = []; // No picks
    var failed_card = assert_fails(play_card_inner(white_player.pub, the_game.game_rowid, last_seen_turn, "FROG", 1, card_picks_none, list<integer>(),
        * // Note, this star is what makes it work.
    ));
    val expected_no_pick_msg: text = "Expected 1 picks for card FROG but got 0";
    assert_true(failed_card.message.starts_with(expected_no_pick_msg));

    log("Turn 1: Card Fail B. Out of board pick for FROG");
    val card_picks_out_of_board = [64]; // Out of board
    failed_card = assert_fails(play_card_inner(white_player.pub, the_game.game_rowid, last_seen_turn, "FROG", 1, card_picks_out_of_board, list<integer>(),
        * // Note, this star is what makes it work.
    ));
    val expected_out_of_board_pick: text = "Pick at pos 0 is out of board.";
    assert_true(failed_card.message.starts_with(expected_out_of_board_pick));

    log("Turn 1: Card Fail C. Free square pick for FROG");
    val card_picks_free = [18]; // = c3, free square
    failed_card = assert_fails(play_card_inner(white_player.pub, the_game.game_rowid, last_seen_turn, "FROG", 1, card_picks_free, list<integer>(),
        * // Note, this star is what makes it work.
    ));
    val expected_must_be_piece_msg: text = "Expected pick at pos 0 to be type PIECE_NON_KING_SQUARE but found a free square at position 18.";
    assert_true(failed_card.message.starts_with(expected_must_be_piece_msg));

    // --------------------
    // /Failed White Cards
    // --------------------

    log("Turn 1: White playes a card");
    val black_rook_to_frog = 56; // a8, Turns black rook into frog
    rell.test.tx(play_card(the_game.game_rowid, last_seen_turn, "FROG", 1, [black_rook_to_frog], list<integer>())).sign(white_player).run();
    last_seen_turn += 1;

    // --------------------
    // Failed White moves
    // --------------------
    // 1: r  kn b  q  k  b  kn r // <- Lower case for black
    // 2: p  p  p  p  p  p  p  p 
    // 3: .  .  .  .  .  .  .  .
    // 4: .  .  .  .  .  .  .  .
    // 5: .  .  .  .  .  .  .  .
    // 6: .  .  .  .  .  .  .  .
    // 7: P  P  P  P  P  P  P  P // <- Upper case for white
    // 8: R  Kn B  Q  K  B  Kn R
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------
    // First we try a few invalid moves, to make sure the validation works.

    log("Turn 2: Move Fail A. No piece at position");
    val wrong_orig_pos = 22; // Nothing on this position
    val wrong_to_pos = 23; 

    var m_args = move_arguments(
        game_id = the_game.game_rowid, 
        last_seen_turn = last_seen_turn, 
        from_position = wrong_orig_pos, // <-- Wrong
        to_position = wrong_to_pos,  // <-- Wrong
        piece_type_str = "BISHOP", // <-- Ok
        given_is_knighted = false);

    var check_args = move_check_arguments(
        is_check = false, 
        is_checkmate = false, 
        is_stalemate = false);

    var failed_move = assert_fails(move_peaceful_inner(white_player.pub, m_args, null, null, check_args,
        * // Note, this star is what makes it work.
        ));
    val expected_wrong_pos: text = "No piece at position " + wrong_orig_pos;
    assert_true(failed_move.message.starts_with(expected_wrong_pos));

    log("Turn 2: Move Fail B. Wrong piece_type at position");
    val knight_orig_pos = 1; // b1 (correct)
    val knight_to_pos = 16;  // a3 (Valid move)

    m_args = move_arguments(
        game_id = the_game.game_rowid, 
        last_seen_turn = last_seen_turn, 
        from_position = knight_orig_pos, // <-- Ok
        to_position = knight_to_pos, // <-- Ok
        piece_type_str = "BISHOP",  // <-- Wrong
        given_is_knighted = false); 

    failed_move = assert_fails(move_peaceful_inner(white_player.pub, m_args, null, null, check_args,
        * // Note, this star is what makes it work.
    ));
    val expected_wrong_type: text = "Expected piece to have active type KNIGHT but got BISHOP";
    assert_true(failed_move.message.starts_with(expected_wrong_type));

    log("Turn 2: Move Fail C. Invalid move pattern");
    val knight_to_wrong_pos = 17;  // b3 (Invalid move)

    m_args = move_arguments(
        game_id = the_game.game_rowid, 
        last_seen_turn = last_seen_turn, 
        from_position = knight_orig_pos, // <-- Ok
        to_position = knight_to_wrong_pos, // <-- Wrong
        piece_type_str = "KNIGHT", // <-- Ok
        given_is_knighted = false);

    failed_move = assert_fails(move_peaceful_inner(white_player.pub, m_args, null, null, check_args,
        * // Note, this star is what makes it work.
    ));
    log(failed_move.message);
    val expected_wrong_move: text = "Illegal move";
    assert_true(failed_move.message.starts_with(expected_wrong_move));


    log("Turn 2: Move Fail D. Bishop cannot move to own piece!");
    val bishop_orig_pos = 2; // c1 (correct)
    val bishop_to_pos = 9; // Vaild move pattern, but pawn here, cannot move this way

    m_args = move_arguments(
        game_id = the_game.game_rowid, 
        last_seen_turn = last_seen_turn, 
        from_position = bishop_orig_pos, // <-- Ok
        to_position = bishop_to_pos, // <-- Ok, but occupied 
        piece_type_str = "BISHOP",  // <-- Ok
        given_is_knighted = false);

    failed_move = assert_fails(move_peaceful_inner(white_player.pub, m_args, null, null, check_args,
        * // Note, this star is what makes it work.
    ));
    val expected_move_on_friend: text = "Illegal move";
    assert_true(failed_move.message.starts_with(expected_move_on_friend));

    // --------------------
    // /Failed White moves
    // --------------------

    log("Turn 2: White makes a valid move Kn b1->a3");

    m_args = move_arguments(
        game_id = the_game.game_rowid, 
        last_seen_turn = last_seen_turn, 
        from_position = knight_orig_pos, // <-- Ok
        to_position = knight_to_pos, // <-- Ok
        piece_type_str = "KNIGHT",  // <-- Ok
        given_is_knighted = false);

    rell.test.tx(move_peaceful(m_args, null, null, check_args)).sign(white_player).run();
    last_seen_turn += 1;

    log ("Turn 3: Skip neutral.");
    rell.test.tx(skip_neutral(the_game.game_rowid, last_seen_turn)).sign(white_player).run();
    last_seen_turn += 1;

    // +++++++++++++++++++++++++++++++++++++++++ BLack Move 1 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 1: r  kn b  q  k  b  kn r
    // 2: p  p  p  p  p  p  p  p
    // 3: .  .  .  .  .  .  .  .
    // 4: .  .  .  .  .  .  .  .
    // 5: .  .  .  .  .  .  .  .
    // 6: .  .  Kn .  .  .  .  .
    // 7: P  P  P  P  P  P  P  P
    // 8: R  .  B  Q  K  B  Kn R
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------
    log ("Turn 4: Black skips spell");
    rell.test.tx(skip_card(the_game.game_rowid, last_seen_turn)).sign(black_player).run();
    last_seen_turn += 1;

    log ("Turn 5: Black moves pawn a7->a5");
    val black_move_1_from = 48; // a7
    val black_move_1_to = 32; // a5 = Pawn double move 

    m_args = move_arguments(
        game_id = the_game.game_rowid, 
        last_seen_turn = last_seen_turn, 
        from_position = black_move_1_from, 
        to_position = black_move_1_to, 
        piece_type_str = "PAWN", 
        given_is_knighted = false); 

    rell.test.tx(move_peaceful(m_args, null, null, check_args)).sign(black_player).run();
    last_seen_turn += 1;

    log ("Turn 6: Skip neutral.");
    rell.test.tx(skip_neutral(the_game.game_rowid, last_seen_turn)).sign(black_player).run();
    last_seen_turn += 1;

    // +++++++++++++++++++++++++++++++++++++++++ White Move 2 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 1: r  kn b  q  k  b  kn r
    // 2: .  p  p  p  p  p  p  p
    // 3: .  .  .  .  .  .  .  .
    // 4: p  .  .  .  .  .  .  .
    // 5: .  .  .  .  .  .  .  .
    // 6: .  .  Kn .  .  .  .  .
    // 7: P  P  P  P  P  P  P  P
    // 8: R  .  B  Q  K  B  Kn R
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------

    log("Turn 7: White plays Knighted.");
    val card_picks_knighted = [10]; // Turns c2 pawn into knight
    rell.test.tx(play_card(the_game.game_rowid, last_seen_turn, "KNIGHTED", 2, card_picks_knighted, list<integer>())).sign(white_player).run();
    last_seen_turn += 1;

    log("Turn 8: White makes a valid move Pawn g2 -> g3");

    m_args = move_arguments(
        game_id = the_game.game_rowid, 
        last_seen_turn = last_seen_turn, 
        from_position = 14,
        to_position = 22,
        piece_type_str = "PAWN", 
        given_is_knighted = false);

    rell.test.tx(move_peaceful(m_args, null, null, check_args)).sign(white_player).run();
    last_seen_turn += 1;

    log ("Turn 9: Skip neutral.");
    rell.test.tx(skip_neutral(the_game.game_rowid, last_seen_turn)).sign(white_player).run();
    last_seen_turn += 1;

    // +++++++++++++++++++++++++++++++++++++++++ BLack Move 2 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 1: r  kn b  q  k  b  kn r
    // 2: .  p  p  p  p  p  p  p
    // 3: .  .  .  .  .  .  .  .
    // 4: p  .  .  .  .  .  .  .
    // 5: .  .  .  .  .  .  .  .
    // 6: .  .  Kn .  .  .  P  .
    // 7: P  P  P  P  P  P  .  P
    // 8: R  .  B  Q  K  B  Kn R
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------
    log ("Turn 10: Black skips spell");
    rell.test.tx(skip_card(the_game.game_rowid, last_seen_turn)).sign(black_player).run();
    last_seen_turn += 1;

    // --------------------
    // Failed Blakc moves
    // --------------------
    // First we try to move the rook link usually, but its ACTIVE TYPE is a frog, so shouldn't work.
    log ("Turn 11: Failed Black Rook (=actually a Frog) moves a8->a6");
    val rook_to_wrong_pos = 40;  // a6 (Cannot move two steps since is frog)

    m_args = move_arguments(
        game_id = the_game.game_rowid, 
        last_seen_turn = last_seen_turn, 
        from_position = black_rook_to_frog,
        to_position = rook_to_wrong_pos, // <-- Wrong, is frog now
        piece_type_str = "ROOK",  // <-- Wrong, is frog now
        given_is_knighted = false);
    
    failed_move = assert_fails(move_peaceful_inner(black_player.pub, m_args, null, null, check_args,
        * // Note, this star is what makes it work.
    ));
    val expected_rook_vs_frog = "Expected piece to have active type FROG but got ROOK";
    assert_true(failed_move.message.starts_with(expected_rook_vs_frog));

    // If we call the frog a FROG, can it move as a rook?
    log ("Turn 11: Failed Black Frog moves a8->a6");

    m_args = move_arguments(
        game_id = the_game.game_rowid, 
        last_seen_turn = last_seen_turn, 
        from_position = black_rook_to_frog,
        to_position = rook_to_wrong_pos, // <-- Wrong
        piece_type_str = "FROG",  // <-- Ok
        given_is_knighted = false);
 
    failed_move = assert_fails(move_peaceful_inner(black_player.pub, m_args, null, null, check_args,
        * // Note, this star is what makes it work.
    ));
    log(failed_move.message);
    assert_true(failed_move.message.starts_with(expected_wrong_move));

    // --------------------
    // /Failed Blakc moves
    // --------------------

    log ("Turn 11: Black moves pawn a5->a4");
    val a5 = 32; 
    val a4 = 24; 

    m_args = move_arguments(
        game_id = the_game.game_rowid, 
        last_seen_turn = last_seen_turn, 
        from_position = a5, // <-- Ok
        to_position = a4, // <-- Ok
        piece_type_str = "PAWN",  // <-- Ok
        given_is_knighted = false);

    rell.test.tx(move_peaceful(m_args, null, null, check_args)).sign(black_player).run();
    last_seen_turn += 1;
    
    log ("Turn 12: Skip neutral.");
    rell.test.tx(skip_neutral(the_game.game_rowid, last_seen_turn)).sign(black_player).run();
    last_seen_turn += 1;

    // +++++++++++++++++++++++++++++++++++++++++ White Move 3 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 1: r  kn b  q  k  b  kn r
    // 2: .  p  p  p  p  p  p  p
    // 3: .  .  .  .  .  .  .  .
    // 4: .  .  .  .  .  .  .  .
    // 5: P  .  .  .  .  .  .  .
    // 6: .  .  Kn .  .  .  P  .
    // 7: P  P  P  P  P  P  .  P
    // 8: R  .  B  Q  K  B  Kn R
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------

    log("Turn 13: White skips spell.");
    rell.test.tx(skip_card(the_game.game_rowid, last_seen_turn)).sign(white_player).run();
    last_seen_turn += 1;

    log("Turn 14: White makes a valid move Pawn b2 -> b4. Opens for en passant.");
    val b2 = 9;
    val b4 = 25;

    m_args = move_arguments(
        game_id = the_game.game_rowid, 
        last_seen_turn = last_seen_turn, 
        from_position = b2, // <-- Ok
        to_position = b4, // <-- Ok
        piece_type_str = "PAWN",  // <-- Ok
        given_is_knighted = false);

    rell.test.tx(move_peaceful(m_args, null, null, check_args)).sign(white_player).run();
    last_seen_turn += 1;

    log ("Turn 15: Skip neutral.");
    rell.test.tx(skip_neutral(the_game.game_rowid, last_seen_turn)).sign(white_player).run();
    last_seen_turn += 1;

    // +++++++++++++++++++++++++++++++++++++++++ BLack Move 3 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 1: r  kn b  q  k  b  kn r
    // 2: .  p  p  p  p  p  p  p
    // 3: .  .  .  .  .  .  .  .
    // 4: .  .  .  .  .  .  .  .
    // 5: p  P  .  .  .  .  .  .
    // 6: .  .  Kn .  .  .  P  .
    // 7: P  .  P  P  P  P  .  P
    // 8: R  .  B  Q  K  B  Kn R
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------

    log ("Turn 16: Black skips spell");
    rell.test.tx(skip_card(the_game.game_rowid, last_seen_turn)).sign(black_player).run();
    last_seen_turn += 1;

    log ("Turn 17: Black captuers pawn a4->b3, via en passant");
    val b3 = 17;

    m_args = move_arguments(
        game_id = the_game.game_rowid, 
        last_seen_turn = last_seen_turn, 
        from_position = a4, 
        to_position = b3, // <-- En passant
        piece_type_str = "PAWN",  
        given_is_knighted = false);


    // Attack data, mandatory for attacks.
    var att_args = move_attack_arguments (
        attacked_position = b3, 
        attack_result_type_str = "KILL", 
        defender_defense_points = 3, 
        damage_points = 7 
    );

    rell.test.tx(move_attack(m_args, att_args, list<integer>(), check_args)).sign(black_player).run();
    last_seen_turn += 1;
    
    log ("Turn 18: Skip neutral.");
    rell.test.tx(skip_neutral(the_game.game_rowid, last_seen_turn)).sign(black_player).run();
    last_seen_turn += 1;

    // +++++++++++++++++++++++++++++++++++++++++ White Move 4 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 1: r  kn b  q  k  b  kn r
    // 2: .  p  p  p  p  p  p  p
    // 3: .  .  .  .  .  .  .  .
    // 4: .  .  .  .  .  .  .  .
    // 5: .  x  .  .  .  .  .  . // <- Pawn on a5 is captured
    // 6: .  p  Kn .  .  .  P  .
    // 7: P  .  P  P  P  P  .  P
    // 8: R  .  B  Q  K  B  Kn R
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------

}



/*
// Not testing anything, just printing the numbers
// to see if any are missing
function test_random() {

    val random_numbers = generate_random_numbers(1238567, 1000, 11);

    var str = "rnd: ";
    val sorted_map = map<integer, integer>();  
    for (n in random_numbers) {
        str += n.to_text() + ", ";
        if (sorted_map.contains(n)) {
            val cnt = sorted_map[n];
            sorted_map[n] = cnt + 1;
        } else {
            sorted_map[n] = 1;
        }
    }

    log(str);

    for (i in range(12)) { // <- 0-11
        if (sorted_map.contains(i)) {
            log(i.to_text() + " = " + sorted_map[i].to_text());
        } else {
            log(i.to_text() + " = NOTHING!? ");
        }
    }
}
*/



