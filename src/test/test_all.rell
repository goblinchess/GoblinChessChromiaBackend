@test module;

import ^^.main.*; // Import all the things from parent folder 
import ^^.card.*;
import ^^.piece.*;
import ^^.move.*;
import ^^.turn.*;

// Helper function to quickly turn "random" integers into rnd_data.
function build_d6_rnd_data(rnds: list<integer>): list<rnd_data> {
    val res_list: list<rnd_data> = [];
    for(rnd in rnds) {
        val rnd_data = rnd_data(
            result = rnd,
            min = 1,
            max = 6
        );
        res_list.add(rnd_data);
    }
    return res_list;
}

function test_move_encode_decode() {
    val positions = [7, 16, 62];
    val enc_path = move_encode_int_pos_list(positions);
    val decoded_positions = move_dencode_text_pos_list(enc_path);

    assert_equals(positions, decoded_positions);
}

// ----------------------------------
// Random
// ----------------------------------

// Just to print out various numbers to see if they are random.
function test_d10() {
    var curr_seed = 1234567890;
    val x: random_results = generate_random_numbers(curr_seed, 50, 9);
    //curr_seed = x.new_seed;

    var msg = "";
    for (res in x.results) {
        msg += res + ", ";
    }

    log("test_d10(): new_seed: " + x.new_seed + " d10: " + msg);
}

function test_d6() {
    var my_seed = 1234567890;
    //curr_seed = x.new_seed;

    var msg = "";
    for (i in range(0, 50)) {
        var (result: integer, curr_seed: integer) = random_generate_number(my_seed, 1, 6);
        my_seed = curr_seed;
        msg += result + ", ";
    }

    log("test_d6(): new_seed: " + my_seed + " d6: " + msg);
}

function test_random_new_numbers_list() {
    val rnd_results: list<rnd_result> = [
        rnd_result(result = 1, type = rnd_nr_type.DICE_ROLL, min = 1, max = 6),
        rnd_result(result = 2, type = rnd_nr_type.DICE_ROLL, min = 1, max = 6),
        rnd_result(result = 3, type = rnd_nr_type.DICE_ROLL, min = 1, max = 6)
    ];
    val rnd_numbers: list<rnd_data> = build_d6_rnd_data([1, 2, 3, 4, 5, 6]);
    val new_rnd_numbers = rnd_new_rnd_data_list(rnd_results, rnd_numbers);
    val expected_new_rnd_numbers = build_d6_rnd_data([4, 5, 6]);
    assert_equals(new_rnd_numbers, expected_new_rnd_numbers);
}

// ------------------------------------------
// Color rotation <-> turn number
// ------------------------------------------
function test_color_rotation_find_max_turn_nr() {
    var max_turn_nr = -1;

    max_turn_nr = color_rotation_find_max_turn_nr(0);
    assert_equals(max_turn_nr, 3);

    max_turn_nr = color_rotation_find_max_turn_nr(1);
    assert_equals(max_turn_nr, 3);

    max_turn_nr = color_rotation_find_max_turn_nr(2);
    assert_equals(max_turn_nr, 3);
    
    max_turn_nr = color_rotation_find_max_turn_nr(3);
    assert_equals(max_turn_nr, 6);

    max_turn_nr = color_rotation_find_max_turn_nr(4);
    assert_equals(max_turn_nr, 6);
    
    max_turn_nr = color_rotation_find_max_turn_nr(5);
    assert_equals(max_turn_nr, 6);
    
    max_turn_nr = color_rotation_find_max_turn_nr(6);
    assert_equals(max_turn_nr, 9);
    
}

// ------------------------------------------
// This test corresponds to the RandomBoxOnlineTest on the server.
// You have to manually make sure the number are the same.
// 
// Here we are duplicating the code from module 
// rnd_validation.rnd_validation_of_player().
// ------------------------------------------
function test_same_as_on_crient_side() {
    val org_seed = 123172398125;

    // Generate hand
    val x: random_results = generate_random_numbers(org_seed, 5, 9);
    var curr_seed = x.new_seed;

    for (idx in range(0, 5)) {
        val rnd_val = x.results[idx];
        val card_type = card_get_type_from_index(rnd_val);
        log(idx + ": rnd_num: " + rnd_val + " card_type: " + card_type);
    }

    // Playing Portal
    var r = random_generate_number(curr_seed, 0, 31); // Half of the board, all empty squares
    curr_seed = r.curr_seed;
    log("Portal: rand result: " + r.result);

    // Playing Portal
    r = random_generate_number(curr_seed, 0, 7); // First row 
    curr_seed = r.curr_seed;
    log("Resurrect: rand result: " + r.result);
}

// ----------------------------------
// Battle 
// ----------------------------------

// Setup a case where the defender has a strong defence,
// so we might provoke retaliation.
function test_battle_strong_defence() {
    val can_retaliate = true;
    val flash_attack = false; 
    val chaos_args = move_chaos_mode_arguments(
        defender_can_retaliate = can_retaliate,
        is_flash_attack = flash_attack,
        is_luck = false
    );

    val def_hp = 10;
    val def_defense = 4;
    val def_strength = die_set_get_default_chaotic(); 

    val att_hp = 4;
    val att_defense = 1;
    val att_strength = die_set_get_default_chaotic();

    // ----------------
    log("Test 8= rnd = 1+3, expect Hit with 4 damage, retaliation Miss");
    // ----------------
    var rnd_datas = build_d6_rnd_data([1, 3, 2]); // NOTE: one extra due to "miss" calculation
    var br = calculate_chaos_attack_result(
        0,
        def_hp, def_strength, def_defense,
        att_hp, att_strength, att_defense,
        chaos_args,
        rnd_datas 
         
    );

    // Attack failed
    assert_equals(br.result, battle_result_type.MISS);
    assert_equals(br.defender_lost_hp, 0); // 4 - 4 = 0
    // Retaliation failed
    assert_equals(br.retaliation_result, battle_result_type.ERROR);
    assert_equals(br.attacker_lost_hp, 0);

    // ----------------
    log("Test 2: rnd = 2,3,2,2 expect hit with 5 damage.");
    // ----------------
    rnd_datas = build_d6_rnd_data([2,3,2,2]);
    br = calculate_chaos_attack_result(
        0,
        def_hp, def_strength, def_defense,
        att_hp, att_strength, att_defense,
        chaos_args,
        rnd_datas 
    );
    // Attack success
    assert_equals(br.result, battle_result_type.HIT);
    assert_equals(br.defender_lost_hp, 1); // 5 -4 = 1
    // Retaliation fails
    assert_equals(br.retaliation_result, battle_result_type.MISS); // 4 - 1 +(-7) = -4
    assert_equals(br.attacker_lost_hp, 0);

    // ----------------
    log("Test 6= rnd = 2,6,5,6 expect Hit with 8 damage, retaliation hit");
    // ----------------
    rnd_datas = build_d6_rnd_data([2,6,5,6]);
    br = calculate_chaos_attack_result(
        0,
        def_hp, def_strength, def_defense,
        att_hp, att_strength, att_defense,
        chaos_args,
        rnd_datas
    );
    // Attack success
    assert_equals(br.result, battle_result_type.HIT);
    assert_equals(br.defender_lost_hp, 4); // 8 -4 = 4
    assert_equals(br.retaliation_result, battle_result_type.HIT);
    assert_equals(br.attacker_lost_hp, 3); // 11 - 1 +(-7) = 3

    // ----------------
    log("Test 5= rnd = 3,6,6,6 expect Hit with 9 damage, retaliation kill");
    // ----------------

    rnd_datas = build_d6_rnd_data([3,6,6,6]);
    br = calculate_chaos_attack_result(
        0,
        def_hp, def_strength, def_defense,
        att_hp, att_strength, att_defense,
        chaos_args,
        rnd_datas 
    );
    // Attack success
    assert_equals(br.result, battle_result_type.HIT);
    assert_equals(br.defender_lost_hp, 5); // 9 -4 = 5
    assert_equals(br.retaliation_result, battle_result_type.KILL); // 12 - 1 +(-7) = 4
}

// ----------------------------------
// ELO
// ----------------------------------
function test_elo_draw_1() {

   val player1_rating: integer = 1200;
   val player2_rating: integer = 1200;

    val (p1: integer, p2: integer) = elo.update_chess_ratings_on_draw(
        player1_rating,
        player2_rating
    );

    assert_equals(p1, 1200);
    assert_equals(p2, 1200);
}

function test_elo_draw_2() {

   val player1_rating: integer = 1300;
   val player2_rating: integer = 1200;

    val (p1: integer, p2: integer) = elo.update_chess_ratings_on_draw(
        player1_rating,
        player2_rating
    );

    assert_equals(p1, 1296);
    assert_equals(p2, 1204);
}


function test_elo_win_1() {

   val player1_rating: integer = 1200;
   val player2_rating: integer = 1200;

    val (p1: integer, p2: integer) = elo.update_chess_ratings_on_win(
        player1_rating, // 1 is winner
        player2_rating // Loser
    );

    assert_equals(p1, 1216);
    assert_equals(p2, 1184);
}

function test_elo_win_2() {
   val winner_rating: integer = 1200;
   val loser_rating: integer = 1300;

    val (w: integer, l: integer) = elo.update_chess_ratings_on_win(
        winner_rating, 
        loser_rating 
    );

    assert_equals(w, 1220);
    assert_equals(l, 1280);
}

// ----------------------------------
// Power Of 
// ----------------------------------

// Basic math thes
function test_ten_to_the_power_of() {
    val x = 1.0;
    val result = ten_to_the_power_of(x);
    log("10 ^ 1=" + result.to_text());
    assert_true(result < 10.001);
    assert_true(result > 9.999);
    
    val x2 = 2.0;
    val result2 = ten_to_the_power_of(x2);
    log("10 ^ 2=" + result2.to_text());
    assert_true(result2 < 100.001);
    assert_true(result2 > 99.999);
}

function test_game_timeout_calc() {

    val game_id = 1;

    // First we need to get the current time
    val curr_time_ms: timestamp = 0; // Only for test.

    val less_than_a_minute_ms = 59* 1000;
    val more_than_a_minute_ms = 61* 1000;
    val ten_minutes_ms = 10*60*1000;

    // Not timed out yet
    var otd = opponent_timeout_data(
        opp_last_heartbeat = curr_time_ms - less_than_a_minute_ms, // Not timed out yet, since 59 sec old heartbeat
        last_color_rotation_at = curr_time_ms - more_than_a_minute_ms, // The last time the color rotation was completed 61 sec ago.
        opp_tot_time_left_since_color_rotation_ms = ten_minutes_ms, // The opponent has 10 minutes left when the "move" (= color rotation) began.
    );
    var result = game_timeout_calc_primitive_curr_time(game_id, otd);
    assert_equals(result, false);

    // Timed out due to old heartbeat
    otd = opponent_timeout_data(
        opp_last_heartbeat = curr_time_ms - more_than_a_minute_ms, // Timed out due to old heartbeat, since 61 sec ago.
        last_color_rotation_at = curr_time_ms - more_than_a_minute_ms, // The last time the color rotation was completed 61 sec ago.
        opp_tot_time_left_since_color_rotation_ms = ten_minutes_ms, // The opponent has 10 minutes left when the "move" (= color rotation) began.
    );
    result = game_timeout_calc_primitive_curr_time(game_id, otd);
    assert_equals(result, true);

    // Timed out due to total time gone
    otd = opponent_timeout_data(
        opp_last_heartbeat = curr_time_ms - less_than_a_minute_ms, // Not timed out yet, since 59 sec old heartbeat.
        last_color_rotation_at = curr_time_ms - more_than_a_minute_ms, // The last time the color rotation was completed 61 sec ago.
        opp_tot_time_left_since_color_rotation_ms = less_than_a_minute_ms, // The opponent has 59 sec left when the "move" (= color rotation) began.
    );
    result = game_timeout_calc_primitive_curr_time(game_id, otd);
    assert_equals(result, true);

}

// ----------------------------------
// Game
// ----------------------------------

function test_full_game() {

    // ------------
    // Check if DB is empty
    // ------------
    val players: list<rowid> = player@* {} (.rowid);
    assert_equals(players.size(), 0);


    // ------------
    log("Create the players");
    // ------------
     
    // All in one
    rell.test.tx(create_player("Alice")).sign(rell.test.keypairs.alice).run();
    rell.test.tx(create_player("Bob")).sign(rell.test.keypairs.bob).run();
    rell.test.tx(create_player("Charlie")).sign(rell.test.keypairs.charlie).run();
    rell.test.tx(create_player("Dave")).sign(rell.test.keypairs.dave).run();

    // ------------
    log("Check if players are created");
    // ------------
    val players_after: list<rowid> = player@* {} (.rowid);
    assert_equals(players_after.size(), 4);


    rell.test.tx(enter_lobby("SPEED_5_CLASSIC")).sign(rell.test.keypairs.bob).run();
    rell.test.tx(enter_lobby("SPEED_10_CLASSIC")).sign(rell.test.keypairs.charlie).run();
    rell.test.tx(enter_lobby("SPEED_5_CLASSIC")).sign(rell.test.keypairs.dave).run();

    // Alice looks for 10 min match
    val match_10_mins = consume_lobby_entry(rell.test.keypairs.alice.pub, 0, "SPEED_10_CLASSIC");
    // ALice finds Charlie
    val opp_player: pubkey = rell.test.keypairs.charlie.pub;
    assert_equals(match_10_mins, opp_player);

    // ------------
    log("Alice creates a 10 min game with Charlie");
    // ------------
    rell.test.tx(create_game_via_lobby(opp_player, "SPEED_10_CLASSIC")).sign(rell.test.keypairs.alice).run();

    // ------------
    log("Alice looks for the game");
    // ------------
    val found_game: in_game_result? = in_game(rell.test.keypairs.alice.pub);
    assert_not_null(found_game);
    val the_game = found_game;

    // If we need the game entity 
    val g: game = (g: game) @ {g.rowid == rowid(the_game.game_rowid) };

    val alice_white = the_game.is_white;
    var alice_color = "black";
    var white_player = rell.test.keypairs.charlie;
    var black_player = rell.test.keypairs.alice;
    if (alice_white) {
        alice_color = "white";
        white_player = rell.test.keypairs.alice;
        black_player = rell.test.keypairs.charlie;
    }


    assert_equals(the_game.game_type, game_type.SPEED_10_CLASSIC);
    assert_equals(the_game.opponent_pubkey, opp_player);
    assert_equals(the_game.opponent_name, "Charlie");
    assert_equals(the_game.opponent_elo, 1200);
    assert_equals(the_game.curr_turn_nr, 0);

    // ------------
    log("New Game: Verify pieces");
    // ------------
    val pieces = get_my_living_pieces(the_game.game_rowid, true);
    assert_equals(pieces.size(), 16);
    var out_str = alice_color + " pieces: ";
    for (p in pieces) {
        assert_true(p.is_alive);
        assert_equals(p.color_str,"white");
        assert_true(p.active_type_str == p.original_type_str);
        out_str += p.active_type_str + "=" + p.position + "("+ p.remaining_hit_points + "), ";
    }

    log(out_str);

    // Before the game begins, we haven't seen any turns, so we say that the [last_seen_turn] is 0.
    // But, remember that there IS a turn in the database with number 0 (= the FRESH_GAME turn).
    var last_seen_turn = 0; 

    // +++++++++++++++++++++++++++++++++++++++++ White Move 1 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 8= r  kn b  q  k  b  kn r  
    // 7= p  p  p  p  p  p  p  p  // <- Lower case for black
    // 6= .  .  .  .  .  .  .  .
    // 5= .  .  .  .  .  .  .  .
    // 4= .  .  .  .  .  .  .  .
    // 3= .  .  .  .  .  .  .  .
    // 2= P  P  P  P  P  P  P  P // <- Upper case for white
    // 1= R  Kn B  Q  K  B  Kn R
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------
    // "." means free square
    // "-" marks the "prev" position of a piece
    // "+" marks the "next" position of a piece (after move or capture)
    // "@" marks the position where a piece will "appear" (magically, not result of a move)
    // "x" marks the position of a piece that was captured (only relevant for en passant)

    // --------------------
    // Failed White Cards
    // --------------------
    // First we try a few invalid cards, to make sure the validation works.

    var minimal_game: minimal_game_result? = minimal_game_data_get(white_player.pub);
    require (minimal_game != null, "Player is not in a game");
    var reverted_list: list<card_enchantment_reverted> = card_enchantment_revert_timed_out(minimal_game.game, minimal_game.player_game);
    require (reverted_list.size() == 0, "Shouldn't start with timed out enchantments");

    log("Turn 1(1): Card Fail A. No picks for FROG");
    var crd_data = card_played_data(
        card_type_str = "FROG",
        card_order_number = 1,
        card_picks = []
    );
    var failed_card = assert_fails(card_play_inner_core(minimal_game, the_game.game_rowid, last_seen_turn, crd_data, list<rnd_data>(), reverted_list,
        * // Note, this star is what makes it work.
    ));
    val expected_no_pick_msg: text = "Expected 1 picks for card FROG but got 0";
    assert_true(failed_card.message.starts_with(expected_no_pick_msg));

    log("Turn 1(1): Card Fail B. Out of board pick for FROG");
    crd_data = card_played_data(
        card_type_str = "FROG",
        card_order_number = 1,
        card_picks = [64] // Out of board
    );
    failed_card = assert_fails(card_play_inner_core(minimal_game, the_game.game_rowid, last_seen_turn, crd_data, list<rnd_data>(), reverted_list,
        * // Note, this star is what makes it work.
    ));
    val expected_out_of_board_pick: text = "Pick at pos 0 is out of board.";
    log("Err:" + failed_card.message);
    assert_true(failed_card.message.starts_with(expected_out_of_board_pick));

    log("Turn 1(1)= Card Fail C. Free square pick for FROG");

    crd_data = card_played_data(
        card_type_str = "FROG",
        card_order_number = 1,
        card_picks = [18] // = c3, free square
    );
    failed_card = assert_fails(card_play_inner_core(minimal_game, the_game.game_rowid, last_seen_turn, crd_data, list<rnd_data>(), reverted_list,
        * // Note, this star is what makes it work.
    ));
    val expected_must_be_piece_msg: text = "Expected pick at pos 0 to be type PIECE_NON_KING_SQUARE but found a free square at position 18.";
    assert_true(failed_card.message.starts_with(expected_must_be_piece_msg));

    // --------------------
    // /Failed White Cards
    // --------------------

    log("Turn 1(1): White plays FROG (on black rook at a8)");
    val a8 = 56; // Turns black rook into frog
    crd_data = card_played_data(
        card_type_str = "FROG",
        card_order_number = 1,
        card_picks = [a8] 
    );
    rell.test.tx(play_card(the_game.game_rowid, last_seen_turn, crd_data, list<rnd_data>())).sign(white_player).run();

    // Try to fetch the card.
    var recent_actions: color_rotation_actions? = get_opponents_recent_actions(white_player.pub, the_game.game_rowid, last_seen_turn);
    assert_not_null(recent_actions);
    assert_equals(recent_actions.curr_turn_nr, 1);
    assert_false(recent_actions.rotate_color);
    assert_not_null(recent_actions.card_played_data);
    assert_equals(recent_actions.card_played_data.card_type_str, "FROG");
    assert_equals(recent_actions.card_played_data.card_order_number, 1);
    assert_equals(recent_actions.card_played_data.card_picks[0], a8);

    last_seen_turn += 1;

    // --------------------
    // Failed White moves
    // --------------------
    // 8= f  kn b  q  k  b  kn r // <--- next: Rook at a8 is now a frog
    // 7= p  p  p  p  p  p  p  p  
    // 6= .  .  .  .  .  .  .  .
    // 5= .  .  .  .  .  .  .  .
    // 4= .  .  .  .  .  .  .  .
    // 3= .  .  +  .  .  .  .  . // <--- next: Knight b2 -> c3
    // 2= P  P  P  P  P  P  P  P 
    // 1= R  Kn B  Q  K  B  Kn R // <--- next: Knight b2 -> c3
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------
    // First we try a few invalid moves, to make sure the validation works.

    log("Turn 1(2): Move Fail A. No piece at position");
    val wrong_orig_pos = 22; // Nothing on this position
    val wrong_to_pos = 23; 

    var m_args = move_arguments(
        game_id = the_game.game_rowid, 
        last_seen_turn = last_seen_turn, 
        from_position = wrong_orig_pos, // <-- Wrong
        to_position = wrong_to_pos,  // <-- Wrong
        piece_type_str = "BISHOP", // <-- Ok
        given_is_knighted = false, 
        given_is_enchanted_jumper = false);

    var check_args = move_check_arguments(
        is_check = false, 
        is_checkmate = false, 
        is_stalemate = false);

    var failed_move = assert_fails(move_peaceful_inner(white_player.pub, m_args, null, null, check_args,
        * // Note, this star is what makes it work.
        ));
    val expected_wrong_pos: text = "No piece at position " + wrong_orig_pos;
    assert_true(failed_move.message.starts_with(expected_wrong_pos));

    log("Turn 1(2): Move Fail B. Wrong piece_type at position");
    val knight_orig_pos = 1; // b1 (correct)
    val knight_to_pos = 18;  // c3 (Valid move)

    m_args = move_arguments(
        game_id = the_game.game_rowid, 
        last_seen_turn = last_seen_turn, 
        from_position = knight_orig_pos, // <-- Ok
        to_position = knight_to_pos, // <-- Ok
        piece_type_str = "BISHOP",  // <-- Wrong
        given_is_knighted = false, 
        given_is_enchanted_jumper = false); 

    failed_move = assert_fails(move_peaceful_inner(white_player.pub, m_args, null, null, check_args,
        * // Note, this star is what makes it work.
    ));
    val expected_wrong_type: text = "Expected piece to have active type KNIGHT but got BISHOP";
    assert_true(failed_move.message.starts_with(expected_wrong_type));

    log("Turn 1(2): Move Fail C. Invalid move pattern");
    val knight_to_wrong_pos = 17;  // b3 (Invalid move)

    m_args = move_arguments(
        game_id = the_game.game_rowid, 
        last_seen_turn = last_seen_turn, 
        from_position = knight_orig_pos, // <-- Ok
        to_position = knight_to_wrong_pos, // <-- Wrong
        piece_type_str = "KNIGHT", // <-- Ok
        given_is_knighted = false, 
        given_is_enchanted_jumper = false);

    failed_move = assert_fails(move_peaceful_inner(white_player.pub, m_args, null, null, check_args,
        * // Note, this star is what makes it work.
    ));
    log(failed_move.message);
    val expected_wrong_move: text = "Illegal move";
    assert_true(failed_move.message.starts_with(expected_wrong_move));


    log("Turn 1(2): Move Fail D. Bishop cannot move to own piece!");
    val bishop_orig_pos = 2; // c1 (correct)
    val bishop_to_pos = 9; // Vaild move pattern, but pawn here, cannot move this way

    m_args = move_arguments(
        game_id = the_game.game_rowid, 
        last_seen_turn = last_seen_turn, 
        from_position = bishop_orig_pos, // <-- Ok
        to_position = bishop_to_pos, // <-- Ok, but occupied 
        piece_type_str = "BISHOP",  // <-- Ok
        given_is_knighted = false, 
        given_is_enchanted_jumper = false);

    failed_move = assert_fails(move_peaceful_inner(white_player.pub, m_args, null, null, check_args,
        * // Note, this star is what makes it work.
    ));
    val expected_move_on_friend: text = "Illegal move";
    assert_true(failed_move.message.starts_with(expected_move_on_friend));

    // --------------------
    // /Failed White moves
    // --------------------

    log("Turn 1(2): White makes a valid move Kn b1->c3");

    m_args = move_arguments(
        game_id = the_game.game_rowid, 
        last_seen_turn = last_seen_turn, 
        from_position = knight_orig_pos, // <-- Ok
        to_position = knight_to_pos, // <-- Ok
        piece_type_str = "KNIGHT",  // <-- Ok
        given_is_knighted = false, 
        given_is_enchanted_jumper = false);

    rell.test.tx(move_peaceful(m_args, null, null, check_args)).sign(white_player).run();

    log ("Turn 1(3): Skip neutral.");
    val temp_last_seen_turn = last_seen_turn + 1; // Don't want to update the real one, since we should fetch two moves soon.
    rell.test.tx(skip_neutral(the_game.game_rowid, temp_last_seen_turn)).sign(white_player).run();

    // --------------------
    // Try to fetch the two moves.
    // --------------------
    recent_actions = get_opponents_recent_actions(white_player.pub, the_game.game_rowid, last_seen_turn);
    assert_not_null(recent_actions);
    assert_equals(recent_actions.curr_turn_nr, 3);
    assert_true(recent_actions.rotate_color);

    // Primary move
    var primary_move: move_full_data? = recent_actions.primary_move;
    assert_not_null(primary_move);
    var m_data: opponents_move_data? = primary_move.m_data;
    assert_not_null(m_data);
    assert_equals(m_data.from_position, knight_orig_pos);
    assert_equals(m_data.to_position, knight_to_pos);
    assert_false(m_data.is_castle);
    assert_false(m_data.given_is_knighted);
    assert_false(m_data.given_is_enchanted_jumper);

    // Extra move
    assert_null(recent_actions.extra_move);

    last_seen_turn += 1;
    last_seen_turn += 1;

    // +++++++++++++++++++++++++++++++++++++++++ BLack Move 1 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 8= f  kn b  q  k  b  kn r
    // 7= p  p  p  p  p  p  p  p // <--- next: pawn a7 -> a5
    // 6= .  .  .  .  .  .  .  . 
    // 5= +  .  .  .  .  .  .  . // <--- next: pawn a7 -> a5
    // 4= .  .  .  .  .  .  .  .
    // 3= .  .  Kn .  .  .  .  . // <--- prev: Knight b2 -> c3
    // 2= P  P  P  P  P  P  P  P
    // 1= R  -  B  Q  K  B  Kn R // <--- prev: Knight b2 -> c3
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------
    log ("Turn 1(4): Black skips spell");
    rell.test.tx(skip_card(the_game.game_rowid, last_seen_turn)).sign(black_player).run();
    last_seen_turn += 1;

    log ("Turn 1(5): Black moves pawn a7->a5");
    val black_move_1_from = 48; // a7
    val black_move_1_to = 32; // a5 = Pawn double move 

    m_args = move_arguments(
        game_id = the_game.game_rowid, 
        last_seen_turn = last_seen_turn, 
        from_position = black_move_1_from, 
        to_position = black_move_1_to, 
        piece_type_str = "PAWN", 
        given_is_knighted = false, 
        given_is_enchanted_jumper = false); 

    rell.test.tx(move_peaceful(m_args, null, null, check_args)).sign(black_player).run();
    last_seen_turn += 1;

    log ("Turn 1(6): Skip neutral.");
    rell.test.tx(skip_neutral(the_game.game_rowid, last_seen_turn)).sign(black_player).run();
    last_seen_turn += 1;

    // +++++++++++++++++++++++++++++++++++++++++ White Move 2 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 8= f  kn b  q  k  b  kn r
    // 7= -  p  p  p  p  p  p  p // <--- prev: pawn a7 -> a5
    // 6= .  .  .  .  .  .  .  .
    // 5= p  .  .  .  .  .  .  . // <--- prev: pawn a7 -> a5
    // 4= .  .  .  .  .  .  .  .
    // 3= .  .  Kn .  .  .  +  . // <--- next: pawn g2 -> g3 
    // 2= P  P  P  P  P  P  P  P // <--- card: turn c3 into a knight
    // 1= R  .  B  Q  K  B  Kn R
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------

    log("Turn 2(7): White plays KNIGHTED (on c3 pawn).");
    val card_picks_knighted = [10]; // Turns c3 pawn into knight
    crd_data = card_played_data(
        card_type_str = "KNIGHTED",
        card_order_number = 2,
        card_picks = card_picks_knighted,
    );

    rell.test.tx(play_card(the_game.game_rowid, last_seen_turn, crd_data, list<rnd_data>())).sign(white_player).run();
    last_seen_turn += 1;

    log("Turn 2(8): White makes a valid move Pawn g2 -> g3");

    m_args = move_arguments(
        game_id = the_game.game_rowid, 
        last_seen_turn = last_seen_turn, 
        from_position = 14,
        to_position = 22,
        piece_type_str = "PAWN", 
        given_is_knighted = false, 
        given_is_enchanted_jumper = false);

    rell.test.tx(move_peaceful(m_args, null, null, check_args)).sign(white_player).run();
    last_seen_turn += 1;

    log ("Turn 2(9): Skip neutral.");
    rell.test.tx(skip_neutral(the_game.game_rowid, last_seen_turn)).sign(white_player).run();
    last_seen_turn += 1;

    // +++++++++++++++++++++++++++++++++++++++++ BLack Move 2 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 8= f  kn b  q  k  b  kn r
    // 7= .  p  p  p  p  p  p  p
    // 6= .  .  .  .  .  .  .  .
    // 5= p  .  .  .  .  .  .  . // <--- next: pawn a5 -> a4
    // 4= +  .  .  .  .  .  .  . // <--- next: pawn a5 -> a4
    // 3= .  .  Kn .  .  .  P  . // <--- prev: pawn g2 -> g3 
    // 2= P  P  Pk P  P  P  -  P
    // 1= R  .  B  Q  K  B  Kn R
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------
    log ("Turn 2(10): Black skips spell");
    rell.test.tx(skip_card(the_game.game_rowid, last_seen_turn)).sign(black_player).run();
    last_seen_turn += 1;

    // --------------------
    // Failed Blakc moves
    // --------------------
    // First we try to move the rook link usually, but its ACTIVE TYPE is a frog, so shouldn't work.
    // It's only been a frog 2 turns, to the enchantment has not yet timed out.
    log ("Turn 2(11): Failed Black Rook (=actually a Frog) moves a8->a6");
    val rook_to_wrong_pos = 40;  // a6 (Cannot move two steps since is frog)

    m_args = move_arguments(
        game_id = the_game.game_rowid, 
        last_seen_turn = last_seen_turn, 
        from_position = a8,
        to_position = rook_to_wrong_pos, // <-- Wrong, still a frog 
        piece_type_str = "ROOK",  // <-- Wrong, still a frog 
        given_is_knighted = false, 
        given_is_enchanted_jumper = false);
    
    failed_move = assert_fails(move_peaceful_inner(black_player.pub, m_args, null, null, check_args,
        * // Note, this star is what makes it work.
    ));
    val expected_rook_vs_frog = "Expected piece to have active type FROG but got ROOK";
    log("Err:" + failed_move.message);
    assert_true(failed_move.message.starts_with(expected_rook_vs_frog));

    // If we call the frog a FROG, can it move as a rook?
    log ("Turn 2(11): Failed Black Frog moves a8->a6");

    m_args = move_arguments(
        game_id = the_game.game_rowid, 
        last_seen_turn = last_seen_turn, 
        from_position = a8,
        to_position = rook_to_wrong_pos, // <-- Wrong
        piece_type_str = "FROG",  // <-- Ok
        given_is_knighted = false, 
        given_is_enchanted_jumper = false);
 
    failed_move = assert_fails(move_peaceful_inner(black_player.pub, m_args, null, null, check_args,
        * // Note, this star is what makes it work.
    ));
    log(failed_move.message);
    assert_true(failed_move.message.starts_with(expected_wrong_move));

    // --------------------
    // /Failed Blakc moves
    // --------------------

    log ("Turn 2(11): Black moves pawn a5->a4");
    val a5 = 32; 
    val a4 = 24; 

    m_args = move_arguments(
        game_id = the_game.game_rowid, 
        last_seen_turn = last_seen_turn, 
        from_position = a5, // <-- Ok
        to_position = a4, // <-- Ok
        piece_type_str = "PAWN",  // <-- Ok
        given_is_knighted = false, 
        given_is_enchanted_jumper = false);

    rell.test.tx(move_peaceful(m_args, null, null, check_args)).sign(black_player).run();
    last_seen_turn += 1;
    
    log ("Turn 2(12): Skip neutral.");
    rell.test.tx(skip_neutral(the_game.game_rowid, last_seen_turn)).sign(black_player).run();
    last_seen_turn += 1;

    // +++++++++++++++++++++++++++++++++++++++++ White Move 3 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 8= f  kn b  q  k  b  kn r
    // 7= .  p  p  p  p  p  p  p
    // 6= .  .  .  .  .  .  .  .
    // 5= -  .  .  .  .  .  .  . // <--- prev: pawn a5 -> a4
    // 4= P  +  .  .  .  .  .  . // <--- next: pawn b2 -> b4
    // 3= .  .  Kn .  .  .  P  .
    // 2= P  P  Pk P  P  P  .  P // <--- next: pawn b2 -> b4
    // 1= R  .  B  Q  K  B  Kn R
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------

    log("Turn 3(13): White skips spell.");
    rell.test.tx(skip_card(the_game.game_rowid, last_seen_turn)).sign(white_player).run();
    last_seen_turn += 1;

    log("Turn 3(14): White makes a valid move Pawn b2 -> b4. Opens for en passant.");
    val b2 = 9;
    val b4 = 25;

    m_args = move_arguments(
        game_id = the_game.game_rowid, 
        last_seen_turn = last_seen_turn, 
        from_position = b2, // <-- Ok
        to_position = b4, // <-- Ok
        piece_type_str = "PAWN",  // <-- Ok
        given_is_knighted = false, 
        given_is_enchanted_jumper = false);

    rell.test.tx(move_peaceful(m_args, null, null, check_args)).sign(white_player).run();
    last_seen_turn += 1;

    log ("Turn 3(15): Skip neutral.");
    rell.test.tx(skip_neutral(the_game.game_rowid, last_seen_turn)).sign(white_player).run();
    last_seen_turn += 1;

    // +++++++++++++++++++++++++++++++++++++++++ BLack Move 3 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 8= f  kn b  q  k  b  kn r
    // 7= .  p  p  p  p  p  p  p
    // 6= .  .  .  .  .  .  .  .
    // 5= .  .  .  .  .  .  .  .
    // 4= p  P  .  .  .  .  .  . // <--- next: pawn a4 x b3 En passant
    // 3= .  +  Kn .  .  .  P  . // <--- next: pawn a4 x b3 En passant
    // 2= P  -  Pk P  P  P  .  P // <--- prev: pawn b2 -> b4
    // 1= R  .  B  Q  K  B  Kn R
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------

    log ("Turn 3(16): Black skips spell");
    rell.test.tx(skip_card(the_game.game_rowid, last_seen_turn)).sign(black_player).run();
    last_seen_turn += 1;

    log ("Turn 3(17): Black captuers pawn a4->b3, via en passant");
    val b3 = 17;

    m_args = move_arguments(
        game_id = the_game.game_rowid, 
        last_seen_turn = last_seen_turn, 
        from_position = a4, 
        to_position = b3, // <-- En passant
        piece_type_str = "PAWN",  
        given_is_knighted = false, 
        given_is_enchanted_jumper = false);


    // Attack data, mandatory for attacks.
    var att_args = move_attack_arguments (
        attacked_position = b3, 
        attack_result_type_str = "KILL", 
        defender_defense_points = 3, 
        damage_points = 7 
    );

    rell.test.tx(move_attack(m_args, att_args, list<rnd_data>(), check_args)).sign(black_player).run();
    
    log ("Turn 3(18): Skip neutral.");
    val temp_last_seen_turn2 = last_seen_turn + 1; // Don't want to update the real one, since we should fetch two moves soon.
    rell.test.tx(skip_neutral(the_game.game_rowid, temp_last_seen_turn2)).sign(black_player).run();

    // --------------------
    // Try to fetch the two moves.
    // --------------------
    recent_actions = get_opponents_recent_actions(black_player.pub, the_game.game_rowid, last_seen_turn);
    assert_not_null(recent_actions);
    assert_equals(recent_actions.curr_turn_nr, temp_last_seen_turn2 + 1);
    assert_true(recent_actions.rotate_color);

    // Primary move
    primary_move = recent_actions.primary_move;
    assert_not_null(primary_move);
    m_data = primary_move.m_data;
    assert_not_null(m_data);
    assert_equals(m_data.from_position, a4);
    assert_equals(m_data.to_position, b3);
    assert_false(m_data.is_castle);
    assert_false(m_data.given_is_knighted);
    assert_false(m_data.given_is_enchanted_jumper);
    var fetched_att_args: move_attack_arguments? = primary_move.att_args;
    assert_not_null(fetched_att_args);
    assert_equals(fetched_att_args.attacked_position, b3); // <-- Not the same as to_position!
    assert_equals(fetched_att_args.attack_result_type_str, "KILL");
    assert_equals(fetched_att_args.defender_defense_points, 3);
    assert_equals(fetched_att_args.damage_points, 7); 

    // Extra move
    assert_null(recent_actions.extra_move);

    last_seen_turn += 1;
    last_seen_turn += 1;

    // +++++++++++++++++++++++++++++++++++++++++ White Move 4 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 8= f  kn b  q  k  b  kn r
    // 7= .  p  p  p  p  p  p  p
    // 6= .  .  .  .  .  @  .  . // <--- next: Portal travel a2 -> f6
    // 5= .  .  .  .  .  .  .  .
    // 4= -  x  .  .  .  .  .  . // <--- prev: Pawn on a5 is captured
    // 3= .  p  Kn .  .  .  P  . // <--- prev: pawn a4 x b3 En passant
    // 2= P  .  Pk P  P  P  .  P // <--- next: Portal travel a2->f6
    // 1= R  .  B  Q  K  B  Kn R
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------

    log("Turn 4(19): White playes PORTAL (a2->f6)");

    // Bit tricky to figure out what the random number should be to put the exit at f6.
    val a2 = 8;
    val f6 = 45;
    var min_portal_empty_squares = 0;
    var total_empty_squares_on_black_side = 17; // One extra since one pawn crossed to other side
    var max_portal_empty_squares = total_empty_squares_on_black_side - 1;
    var portal_rnd_result = 13; // f6. Start counting from rank 5. 0->7 (=8 steps). Rank 4. 8-> 13 (6 steps)
    var portal_rnd_data = rnd_data(
        result = portal_rnd_result, 
        min = min_portal_empty_squares, 
        max = max_portal_empty_squares
    );
    var rnds: list<rnd_data> = [portal_rnd_data];

    crd_data = card_played_data(
        card_type_str = "PORTAL",
        card_order_number = 2,
        card_picks = [a2, f6],
    );
    rell.test.tx(play_card(the_game.game_rowid, last_seen_turn, crd_data, rnds)).sign(white_player).run();
    last_seen_turn += 1;

    log ("Turn 4(20): White must skip move (due to portal).");
    var end_args = move_end_events_arguments(
        used_portals = [ a2 ], // <-- Portal a2 was used
        resurrection_pos = null, 
        promotions = list<integer>()
    );
    rell.test.tx(skip_move(the_game.game_rowid, last_seen_turn, end_args)).sign(white_player).run();
    last_seen_turn += 1;

    log ("Turn 4(21): Skip neutral.");
    rell.test.tx(skip_neutral(the_game.game_rowid, last_seen_turn)).sign(white_player).run();
    last_seen_turn += 1;

    // +++++++++++++++++++++++++++++++++++++++++ Black Move 4 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 8= r  kn b  q  k  b  kn r // <--- next: Frog -> Rook (enchantment removed)
    // 7= .  p  p  p  p  p  p  p
    // 6= .  .  .  .  .  P  .  . // <--- prev: Pawn moved through new portal a2->f6
    // 5= .  .  .  .  .  .  .  .
    // 4= .  .  .  .  .  .  .  . 
    // 3= .  p  Kn .  .  .  P  .
    // 2= -  .  Pk P  P  P  .  P // <--- prev: Pawn moved through new portal a2->f6
    // 1= R  .  B  Q  K  B  Kn R // <--- next: Rook a8 x a1 (shouldn't cause resurrection)
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------

    // Let's check if the Pawn at a2 moved? 
    val what_a2: piece_living_data? = piece_get_living_data_from_pos(g, 8);
    if (what_a2 != null) {
        log("what at a2: " + what_a2.active_type);
    } else {
        log("what at a2: null");
    }

    // Let's check if there popped up a Pawn at g3? 
    val what_f6: piece_living_data? = piece_get_living_data_from_pos(g, 45);
    if (what_f6 != null) {
        log("what at f6: " + what_f6.active_type);
    } else {
        log("what at f6: null");
    }

    log("Turn 4(22): Black plays RESURRECT");
    crd_data = card_played_data(
        card_type_str = "RESURRECT",
        card_order_number = 5,
        card_picks = [],
    );
    rell.test.tx(play_card(the_game.game_rowid, last_seen_turn, crd_data, list<rnd_data>())).sign(black_player).run();
    last_seen_turn += 1;

    // The A8 rook was turned into a FROG turn 1, but this enchantment should have been removed by now.
    log ("Turn 4(23): Black captuers rook a8->a1");
    val a1 = 0;

    m_args = move_arguments(
        game_id = the_game.game_rowid, 
        last_seen_turn = last_seen_turn, 
        from_position = a8, 
        to_position = a1, 
        piece_type_str = "ROOK",  
        given_is_knighted = false, 
        given_is_enchanted_jumper = false);

    // Attack data, mandatory for attacks.
    att_args = move_attack_arguments (
        attacked_position = a1, 
        attack_result_type_str = "KILL", 
        defender_defense_points = 3, 
        damage_points = 7 
    );

    rell.test.tx(move_attack(m_args, att_args, list<rnd_data>(), check_args)).sign(black_player).run();
    last_seen_turn += 1;

    log ("Turn 4(24): Skip neutral.");
    rell.test.tx(skip_neutral(the_game.game_rowid, last_seen_turn)).sign(black_player).run();
    last_seen_turn += 1;

    // +++++++++++++++++++++++++++++++++++++++++ White Move 5 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 8= -  kn b  q  k  b  kn r // <--- prev: Rook a8 x a1 (shouldn't cause resurrection)
    // 7= .  p  p  p  p  p  p  p
    // 6= .  .  .  .  .  P  .  .
    // 5= .  .  .  .  .  .  .  .
    // 4= .  .  .  .  .  .  .  . 
    // 3= .  p  Kn .  .  .  P  . // <--- next: Pawn takes on c2 x b3 (shouldn't cause resurrection)
    // 2= .  .  Pk P  P  P  .  P // <--- next: Pawn takes on c2 x b3 (shouldn't cause resurrection)
    // 1= r  .  B  Q  K  B  Kn R // <--- prev: Rook a8 x a1 (shouldn't cause resurrection)
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------

    log("Turn 5(25): White also plays RESURRECT.");
    crd_data = card_played_data(
        card_type_str = "RESURRECT",
        card_order_number = 5,
        card_picks = [],
    );
    rell.test.tx(play_card(the_game.game_rowid, last_seen_turn, crd_data, list<rnd_data>())).sign(white_player).run();
    last_seen_turn += 1;

    log ("Turn 5(26): White captuers pawn c2->b3, but no resurrection (Note: pawn is KNIGHTED).");
    val c2 = 10;

    m_args = move_arguments(
        game_id = the_game.game_rowid, 
        last_seen_turn = last_seen_turn, 
        from_position = c2, 
        to_position = b3, 
        piece_type_str = "PAWN",  
        given_is_knighted = true, 
        given_is_enchanted_jumper = false);


    // Attack data, mandatory for attacks.
    att_args = move_attack_arguments (
        attacked_position = b3, 
        attack_result_type_str = "KILL", 
        defender_defense_points = 3, 
        damage_points = 7 
    );

    rell.test.tx(move_attack(m_args, att_args, list<rnd_data>(), check_args)).sign(white_player).run();
    last_seen_turn += 1;
    
    log ("Turn 5(27): Skip neutral.");
    rell.test.tx(skip_neutral(the_game.game_rowid, last_seen_turn)).sign(white_player).run();
    last_seen_turn += 1;

    // +++++++++++++++++++++++++++++++++++++++++ Black Move 5 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 8= .  kn b  q  k  b  kn r
    // 7= .  p  p  p  p  p  p  p // <--- next: Pawn g7 -> g6
    // 6= .  .  .  .  .  P  +  . // <--- next: Pawn g7 -> g6
    // 5= .  .  .  .  .  .  .  .
    // 4= .  .  .  .  .  .  .  . 
    // 3= .  Pk Kn .  .  .  P  . // <--- prev: Pawn takes on c2 x b3 (shouldn't cause resurrection)
    // 2= .  .  -  P  P  P  .  P // <--- prev: Pawn takes on c2 x b3 (shouldn't cause resurrection) 
    // 1= r  .  B  Q  K  B  Kn R  
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------

    log ("Turn 5(28): Black skips spell");
    rell.test.tx(skip_card(the_game.game_rowid, last_seen_turn)).sign(black_player).run();
    last_seen_turn += 1;

    log ("Turn 5(29): Black moves pawn g7->g6, to avoid being taken.");
    val g7 = 54; 
    val g6 = 46; 

    m_args = move_arguments(
        game_id = the_game.game_rowid, 
        last_seen_turn = last_seen_turn, 
        from_position = g7, // <-- Ok
        to_position = g6, // <-- Ok
        piece_type_str = "PAWN",  // <-- Ok
        given_is_knighted = false, 
        given_is_enchanted_jumper = false);

    rell.test.tx(move_peaceful(m_args, null, null, check_args)).sign(black_player).run();
    last_seen_turn += 1;
    
    log ("Turn 5(30): Skip neutral.");
    rell.test.tx(skip_neutral(the_game.game_rowid, last_seen_turn)).sign(black_player).run();
    last_seen_turn += 1;

    // +++++++++++++++++++++++++++++++++++++++++ White Move 6 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 8= .  kn b  q  k  b  kn r
    // 7= .  p  p  p  p  p  -  p // <--- prev: Pawn g7 -> g6
    // 6= .  .  .  .  .  P  p  . // <--- prev: Pawn g7 -> g6
    // 5= .  .  .  .  .  .  .  .
    // 4= +  .  .  .  .  .  .  . // <--- next: Knight c3 -> a4
    // 3= .  Pk Kn .  .  .  P  . // <--- next: Knight c3 -> a4
    // 2= .  .  .  P  P  P  .  P 
    // 1= r  .  B  Q  K  B  Kn R  
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------

    log("Turn 6(31): White skips spell.");
    rell.test.tx(skip_card(the_game.game_rowid, last_seen_turn)).sign(white_player).run();
    last_seen_turn += 1;

    log("Turn 6(32): White makes a valid move Knight c3 -> a4. Blocks rook's escape.");
    val c3 = 18;

    m_args = move_arguments(
        game_id = the_game.game_rowid, 
        last_seen_turn = last_seen_turn, 
        from_position = c3, // <-- Ok
        to_position = a4, // <-- Ok
        piece_type_str = "KNIGHT",  // <-- Ok
        given_is_knighted = false, 
        given_is_enchanted_jumper = false);

    rell.test.tx(move_peaceful(m_args, null, null, check_args)).sign(white_player).run();
    last_seen_turn += 1;

    log ("Turn 6(33): Skip neutral.");
    rell.test.tx(skip_neutral(the_game.game_rowid, last_seen_turn)).sign(white_player).run();
    last_seen_turn += 1;

    // +++++++++++++++++++++++++++++++++++++++++ Black Move 6 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 8= .  kn b  q  k  b  kn r
    // 7= .  p  p  p  p  p  .  p // <--- next: Pawn e7 -> e6
    // 6= .  .  .  .  +  P  p  . // <--- next: Pawn e7 -> e6
    // 5= .  .  .  .  .  .  .  . 
    // 4= Kn .  .  .  .  .  .  . // <--- prev: Knight c3 -> a4
    // 3= .  Pk -  .  .  .  P  . // <--- prev: Knight c3 -> a4
    // 2= .  .  .  P  P  P  .  P 
    // 1= r  .  B  Q  K  B  Kn R  
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------

    log ("Turn 6(34): Black skips spell");
    rell.test.tx(skip_card(the_game.game_rowid, last_seen_turn)).sign(black_player).run();
    last_seen_turn += 1;

    log ("Turn 6(35): Black moves pawn e7->e6, to avoid being taken.");
    val e7 = 52; 
    val e6 = 44; 

    m_args = move_arguments(
        game_id = the_game.game_rowid, 
        last_seen_turn = last_seen_turn, 
        from_position = e7, // <-- Ok
        to_position = e6, // <-- Ok
        piece_type_str = "PAWN",  // <-- Ok
        given_is_knighted = false, 
        given_is_enchanted_jumper = false);

    rell.test.tx(move_peaceful(m_args, null, null, check_args)).sign(black_player).run();
    last_seen_turn += 1;
    
    log ("Turn 6(36): Skip neutral.");
    rell.test.tx(skip_neutral(the_game.game_rowid, last_seen_turn)).sign(black_player).run();
    last_seen_turn += 1;

    // +++++++++++++++++++++++++++++++++++++++++ White Move 7 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 8= .  kn b  q  k  b  kn r
    // 7= .  p  p  p  -  p  .  p // <--- prev: Pawn e7 -> e5
    // 6= .  .  .  .  p  P  p  .
    // 5= .  .  .  .  .  .  .  . // <--- prev: Pawn e7 -> e5
    // 4= Kn .  .  .  .  .  .  . 
    // 3= .  Pk .  .  .  .  P  . 
    // 2= .  .  +  P  P  P  .  P // <-- next: Queen d1 -> c2 
    // 1= r  .  B  Q  K  B  Kn R // <-- next: Queen d1 -> c2 
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------

    log("Turn 7(37): White skips spell.");
    rell.test.tx(skip_card(the_game.game_rowid, last_seen_turn)).sign(white_player).run();
    last_seen_turn += 1;

    log("Turn 7(38): White makes a valid move Queen d1 -> c2. Trying to trap the rook.");
    val d1 = 3;

    m_args = move_arguments(
        game_id = the_game.game_rowid, 
        last_seen_turn = last_seen_turn, 
        from_position = d1, // <-- Ok
        to_position = c2, // <-- Ok
        piece_type_str = "QUEEN",  // <-- Ok
        given_is_knighted = false, 
        given_is_enchanted_jumper = false);

    rell.test.tx(move_peaceful(m_args, null, null, check_args)).sign(white_player).run();
    last_seen_turn += 1;

    log ("Turn 7(39): Skip neutral.");
    rell.test.tx(skip_neutral(the_game.game_rowid, last_seen_turn)).sign(white_player).run();
    last_seen_turn += 1;

    // +++++++++++++++++++++++++++++++++++++++++ Black Move 7 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 8= @  kn b  q  k  b  kn r // <-- next: Queen d8 x f6 (will cause resurrection)
    // 7= .  p  p  p  .  p  .  p
    // 6= .  .  .  .  p  P  p  . // <-- next: Queen d8 x f6 (will cause resurrection)
    // 5= .  .  .  .  .  .  .  .
    // 4= Kn .  .  .  .  .  .  . 
    // 3= .  Pk .  .  .  .  P  . 
    // 2= .  .  Q  P  P  P  .  P // <-- prev: Queen d1 -> c2
    // 1= r  .  B  -  K  B  Kn R // <-- prev: Queen d1 -> c2   
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------

    log ("Turn 7(40): Black skips spell");
    rell.test.tx(skip_card(the_game.game_rowid, last_seen_turn)).sign(black_player).run();
    last_seen_turn += 1;

    log ("Turn 7(41): Black captures pawn d8->f6, causing resurrection.");
    val d8 = 59;

    m_args = move_arguments(
        game_id = the_game.game_rowid, 
        last_seen_turn = last_seen_turn, 
        from_position = d8, 
        to_position = f6, 
        piece_type_str = "QUEEN",  
        given_is_knighted = false, 
        given_is_enchanted_jumper = false);

    // Attack data, mandatory for attacks.
    att_args = move_attack_arguments (
        attacked_position = f6, 
        attack_result_type_str = "KILL", 
        defender_defense_points = 3, 
        damage_points = 7 
    );

    end_args = move_end_events_arguments(
        used_portals = list<integer>(),
        resurrection_pos = a8, // First free position at first rank
        promotions = list<integer>()
    );

    rell.test.tx(move_attack(m_args, att_args, list<rnd_data>(), check_args, end_args)).sign(black_player).run();
    last_seen_turn += 1;

    log ("Turn 7(42): Skip neutral.");
    rell.test.tx(skip_neutral(the_game.game_rowid, last_seen_turn)).sign(black_player).run();
    last_seen_turn += 1;

    // +++++++++++++++++++++++++++++++++++++++++ White Move 8 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 8= p  kn b  -  k  b  kn r // <-- prev: pawn resurrected at a8.
    // 7= .  p  p  p  .  p  .  p
    // 6= .  .  .  .  p  q  p  . // <-- prev: Captured by Queen d8 x f6 (will cause resurrection)
    // 5= .  .  .  .  .  .  .  .
    // 4= Kn .  .  .  .  .  .  . 
    // 3= .  Pk .  .  .  .  P  . // <-- next: Instead KNIGHTED pawn goes b3 x a1, causing the rook to resurrect.
    // 2= .  .  Q  P  P  P  .  P // <-- next: We want to verify that White cannot move Bishop c1 -> d2 (causing check).
    // 1= r  @  B  .  K  B  Kn R // <-- next: 1) KNIGHTED pawn takes b3 x a1. 2) Resurrect at b1.
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------

    log("Turn 8(43): White skips spell.");
    rell.test.tx(skip_card(the_game.game_rowid, last_seen_turn)).sign(white_player).run();
    last_seen_turn += 1;

    // --------------------
    // Failed White moves
    // --------------------
    log("Turn 8(44): Move Fail . Bishop cannot move c1 -> b2 to put king in check!");
    val c1 = 2; // c1 (correct)

    m_args = move_arguments(
        game_id = the_game.game_rowid, 
        last_seen_turn = last_seen_turn, 
        from_position = c1, // <-- Ok
        to_position = b2, // <-- Valid bishop move, but will cause check
        piece_type_str = "BISHOP",  
        given_is_knighted = false, 
        given_is_enchanted_jumper = false);

    failed_move = assert_fails(move_peaceful_inner(white_player.pub, m_args, null, null, check_args,
        * // Note, this star is what makes it work.
    ));
    val expected_move_causes_check: text = "Move puts us into check: type: BISHOP";
    log(failed_move.message);
    assert_true(failed_move.message.starts_with(expected_move_causes_check));

    // --------------------
    // /Failed White moves
    // --------------------

    log("Turn 8(44): White makes a valid move KNIGHTED pawn b3 x a1, capturing the rook, causing resurrection.");

     m_args = move_arguments(
        game_id = the_game.game_rowid, 
        last_seen_turn = last_seen_turn, 
        from_position = b3, 
        to_position = a1, 
        piece_type_str = "PAWN",  
        given_is_knighted = true, 
        given_is_enchanted_jumper = false);


    // Attack data, mandatory for attacks.
    att_args = move_attack_arguments (
        attacked_position = a1, 
        attack_result_type_str = "KILL", 
        defender_defense_points = 3, 
        damage_points = 7 
    );

    val b1 = 1;
    end_args = move_end_events_arguments(
        used_portals = list<integer>(),
        resurrection_pos = b1, // First free position at first rank
        promotions = list<integer>()
    );

    rell.test.tx(move_attack(m_args, att_args, list<rnd_data>(), check_args, end_args)).sign(white_player).run();
    last_seen_turn += 1;

    log ("Turn 8(45): Skip neutral.");
    rell.test.tx(skip_neutral(the_game.game_rowid, last_seen_turn)).sign(white_player).run();
    last_seen_turn += 1;


    // +++++++++++++++++++++++++++++++++++++++++ Black Move 8 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 8= p  kn b  .  k  b  kn r
    // 7= .  p  p  p  .  p  .  p
    // 6= .  .  .  .  p  q  p  . // <-- next: queen f6 -> c3
    // 5= .  .  .  .  .  .  .  .
    // 4= Kn .  .  .  .  .  .  . // <-- next: queen f6 -> c3
    // 3= .  -  +  .  .  .  P  . // <-- prev: KNIGHTED pawn takes rook via b3 x a1.
    // 2= .  .  Q  P  P  P  .  P 
    // 1= Pk R  B  .  K  B  Kn R // <-- prev: KNIGHTED pawn goes b3 x a1, causing the rook to resurrect at b1.
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------

    log ("Turn 8(46): Black skips spell");
    rell.test.tx(skip_card(the_game.game_rowid, last_seen_turn)).sign(black_player).run();
    last_seen_turn += 1;

    log ("Turn 8(47): Black moves queen f6 -> c3 (pretty stupid move).");

    m_args = move_arguments(
        game_id = the_game.game_rowid, 
        last_seen_turn = last_seen_turn, 
        from_position = f6, // <-- Ok
        to_position = c3, // <-- Ok
        piece_type_str = "QUEEN",  // <-- Ok
        given_is_knighted = false, 
        given_is_enchanted_jumper = false);

    rell.test.tx(move_peaceful(m_args, null, null, check_args)).sign(black_player).run();
    last_seen_turn += 1;
    
    log ("Turn 8(48): Skip neutral.");
    rell.test.tx(skip_neutral(the_game.game_rowid, last_seen_turn)).sign(black_player).run();
    last_seen_turn += 1;

    // +++++++++++++++++++++++++++++++++++++++++ White Move 9 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 8= p  kn b  .  k  b  kn r
    // 7= .  p  p  p  .  p  .  p // <-- next: JUMP on queen c2 -> c7
    // 6= .  .  .  .  p  -  p  . // <-- prev: queen f6 -> c3
    // 5= .  .  .  .  .  .  .  .
    // 4= Kn .  .  .  .  .  .  . // <-- prev: queen f6 -> c3
    // 3= .  -  q  .  .  .  P  . 
    // 2= .  .  Q  P  P  P  .  P // <-- next: fails to put a PORTAL on d2 (causes check), instead JUMP on queen c2 -> c7
    // 1= Pk R  B  .  K  B  Kn R 
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------

    // Bit tricky to figure out what the random number should be to put the exit b6
    val d2 = 11;
    val b6 = 41;
    total_empty_squares_on_black_side = 18; 
    max_portal_empty_squares = total_empty_squares_on_black_side - 1;
    portal_rnd_result = 10; // b6. Start counting from rank 5. 0->7 (=8 steps). Rank 4. 8-> 9 (2 steps)
    portal_rnd_data = rnd_data(
        result = portal_rnd_result, 
        min = min_portal_empty_squares, 
        max = max_portal_empty_squares
    );
    rnds= [portal_rnd_data];

    log("Turn 9(49): Card Fail, PORTAL on d2 (causes check).");
    minimal_game = minimal_game_data_get(white_player.pub);
    require(minimal_game != null, "Player is not in a game");
    reverted_list = card_enchantment_revert_timed_out(minimal_game.game, minimal_game.player_game);

    crd_data = card_played_data(
        card_type_str = "PORTAL",
        card_order_number = 1,
        card_picks = [d2, b6],
    );
    failed_card = assert_fails(card_play_inner_core(minimal_game, the_game.game_rowid, last_seen_turn, crd_data, rnds, reverted_list,
        * // Note, this star is what makes it work.
    ));
    //log(failed_card.message);
    val expected_portal_check_msg: text = "Cannot use PORTAL on a piece, so that when it moves to the exit it causes a check";
    assert_true(failed_card.message.starts_with(expected_portal_check_msg));

    log("Turn 9(49): White plays JUMP (on Queen on C2).");

    crd_data = card_played_data(
        card_type_str = "JUMP",
        card_order_number = 3,
        card_picks = [c2],
    );
    rell.test.tx(play_card(the_game.game_rowid, last_seen_turn, crd_data, list<rnd_data>())).sign(white_player).run();
    last_seen_turn += 1;

    // --------------------
    // Failed White moves
    // --------------------
    log("Turn 9(50): Move Fail. Bishop cannot move f1 -> d3 (Only the enchanted piece can jump)");
    val f1 = 5; 
    val d3 = 19;

    m_args = move_arguments(
        game_id = the_game.game_rowid, 
        last_seen_turn = last_seen_turn, 
        from_position = f1, // <-- Ok
        to_position = d3, // <-- Only valid bishop move if we can jump
        piece_type_str = "BISHOP",  
        given_is_knighted = false, 
        given_is_enchanted_jumper = false); // <-- We don't claim to be an enchanted jumper

    failed_move = assert_fails(move_peaceful_inner(white_player.pub, m_args, null, null, check_args,
        * // Note, this star is what makes it work.
    ));
    var move_expeceted_err_msg: text = "Illegal move: type: BISHOP";
    //log(failed_move.message);
    assert_true(failed_move.message.starts_with(move_expeceted_err_msg));

    log("Turn 9(50): Move Fail. Bishop cannot move f1 -> d3 (Only the enchanted piece can jump)");

    m_args = move_arguments(
        game_id = the_game.game_rowid, 
        last_seen_turn = last_seen_turn, 
        from_position = f1, // <-- Ok
        to_position = d3, // <-- Only valid bishop move if we can jump
        piece_type_str = "BISHOP",  
        given_is_knighted = false, 
        given_is_enchanted_jumper = true); // <-- NOT TRUE! It's the Queen that got the enchantment.

    failed_move = assert_fails(move_peaceful_inner(white_player.pub, m_args, null, null, check_args,
        * // Note, this star is what makes it work.
    ));
    move_expeceted_err_msg = "This piece is not an enchanted jumper";
    //log(failed_move.message);
    assert_true(failed_move.message.starts_with(move_expeceted_err_msg));

    // --------------------
    // /Failed White moves
    // --------------------

    log("Turn 9(50): White makes a successful jump with the Queen c2 -> c7");
    val c7 = 50;

     m_args = move_arguments(
        game_id = the_game.game_rowid, 
        last_seen_turn = last_seen_turn, 
        from_position = c2, 
        to_position = c7, 
        piece_type_str = "QUEEN",  
        given_is_knighted = false, 
        given_is_enchanted_jumper = true); // <-- MUST SET FLAG! 

    // Attack data, mandatory for attacks.
    att_args = move_attack_arguments (
        attacked_position = c7, 
        attack_result_type_str = "KILL", 
        defender_defense_points = 3, 
        damage_points = 7 
    );

    rell.test.tx(move_attack(m_args, att_args, list<rnd_data>(), check_args, end_args)).sign(white_player).run();
    last_seen_turn += 1;

    log ("Turn 9(51): Skip neutral.");
    rell.test.tx(skip_neutral(the_game.game_rowid, last_seen_turn)).sign(white_player).run();
    last_seen_turn += 1;


    // +++++++++++++++++++++++++++++++++++++++++ Black Move 9 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 8= p  kn b  .  k  b  kn r
    // 7= .  p  Q  p  .  p  .  p // <-- prev: JUMP on queen c2 -> c7
    // 6= .  .  .  .  p  -  p  . 
    // 5= .  .  .  .  .  .  .  .
    // 4= Kn .  .  .  .  .  .  . 
    // 3= .  -  q  .  .  .  P  . 
    // 2= .  .  -  P  P  P  .  P // <-- prev: JUMP on queen c2 -> c7
    // 1= Pk R  B  .  K  B  Kn R 
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------
}



/*
// Not testing anything, just printing the numbers
// to see if any are missing
function test_random() {

    val random_numbers = generate_random_numbers(1238567, 1000, 11);

    var str = "rnd: ";
    val sorted_map = map<integer, integer>();  
    for (n in random_numbers) {
        str += n.to_text() + ", ";
        if (sorted_map.contains(n)) {
            val cnt = sorted_map[n];
            sorted_map[n] = cnt + 1;
        } else {
            sorted_map[n] = 1;
        }
    }

    log(str);

    for (i in range(12)) { // <- 0-11
        if (sorted_map.contains(i)) {
            log(i.to_text() + " = " + sorted_map[i].to_text());
        } else {
            log(i.to_text() + " = NOTHING!? ");
        }
    }
}
*/



