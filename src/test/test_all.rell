@test module;

import ^^.main.*; // Import all the things from parent folder 
import ^^.card.*;
import ^^.piece.*;
import ^^.move.*;
import ^^.turn.*;

// Helper function to quickly turn "random" integers into rnd_data.
function build_d6_rnd_data(rnds: list<integer>): list<rnd_data> {
    val res_list: list<rnd_data> = [];
    for(rnd in rnds) {
        val rnd_data = rnd_data(
            result = rnd,
            min = 1,
            max = 6
        );
        res_list.add(rnd_data);
    }
    return res_list;
}

function test_move_encode_decode() {
    val positions = [7, 16, 62];
    val enc_path = move_encode_int_pos_list(positions);
    val decoded_positions = move_dencode_text_pos_list(enc_path);

    assert_equals(positions, decoded_positions);
}

// ----------------------------------
// Random
// ----------------------------------

// Just to print out various numbers to see if they are random.
function test_d10() {
    var curr_seed = 1234567890;
    val x: random_results = generate_random_numbers(curr_seed, 50, 9);
    //curr_seed = x.new_seed;

    var msg = "";
    for (res in x.results) {
        msg += res + ", ";
    }

    log("test_d10(): new_seed: " + x.new_seed + " d10: " + msg);
}

function test_d6() {
    var my_seed = 1234567890;
    //curr_seed = x.new_seed;

    var msg = "";
    for (i in range(0, 50)) {
        var (result: integer, curr_seed: integer) = random_generate_number(my_seed, 1, 6);
        my_seed = curr_seed;
        msg += result + ", ";
    }

    log("test_d6(): new_seed: " + my_seed + " d6: " + msg);
}

function test_random_new_numbers_list() {
    val rnd_results: list<rnd_result> = [
        rnd_result(result = 1, type = rnd_nr_type.DICE_ROLL, min = 1, max = 6),
        rnd_result(result = 2, type = rnd_nr_type.DICE_ROLL, min = 1, max = 6),
        rnd_result(result = 3, type = rnd_nr_type.DICE_ROLL, min = 1, max = 6)
    ];
    val rnd_numbers: list<rnd_data> = build_d6_rnd_data([1, 2, 3, 4, 5, 6]);
    val new_rnd_numbers = rnd_new_rnd_data_list(rnd_results, rnd_numbers);
    val expected_new_rnd_numbers = build_d6_rnd_data([4, 5, 6]);
    assert_equals(new_rnd_numbers, expected_new_rnd_numbers);
}

// ------------------------------------------
// Color rotation <-> turn number
// ------------------------------------------
function test_player_rotation_find_max_turn_nr() {
    var max_turn_nr = -1;

    max_turn_nr = player_rotation_find_max_turn_nr_and_validate(17, 1, 0);
    assert_equals(max_turn_nr, 3);

    max_turn_nr = player_rotation_find_max_turn_nr_and_validate(17, 1, 1);
    assert_equals(max_turn_nr, 3);

    max_turn_nr = player_rotation_find_max_turn_nr_and_validate(17, 1, 2);
    assert_equals(max_turn_nr, 3);
    
    max_turn_nr = player_rotation_find_max_turn_nr_and_validate(17, 2, 3);
    assert_equals(max_turn_nr, 6);

    max_turn_nr = player_rotation_find_max_turn_nr_and_validate(17, 2, 4);
    assert_equals(max_turn_nr, 6);
    
    max_turn_nr = player_rotation_find_max_turn_nr_and_validate(17, 2, 5);
    assert_equals(max_turn_nr, 6);
    
    max_turn_nr = player_rotation_find_max_turn_nr_and_validate(17, 3, 6);
    assert_equals(max_turn_nr, 9);
    
}

// ------------------------------------------
// This test corresponds to the RandomBoxOnlineTest on the server.
// You have to manually make sure the number are the same.
// 
// Here we are duplicating the code from module 
// rnd_validation.rnd_validation_of_player().
// ------------------------------------------
function test_same_as_on_client_side() {
    val org_seed = 1231723;

    // Generate hand
    val x: random_results = generate_random_numbers(org_seed, 5, 9);
    var curr_seed = x.new_seed;

    for (idx in range(0, 5)) {
        val rnd_val = x.results[idx];
        val card_type = card_get_type_from_index(rnd_val);
        log(idx + ": rnd_num: " + rnd_val + " card_type: " + card_type);
    }

    // Playing Portal
    var r = random_generate_number(curr_seed, 0, 31); // Half of the board, all empty squares
    curr_seed = r.curr_seed;
    log("Portal: rand result: " + r.result);

    // Playing Portal
    r = random_generate_number(curr_seed, 0, 7); // First row 
    curr_seed = r.curr_seed;
    log("Resurrect: rand result: " + r.result);
}

// ----------------------------------
// Battle 
// ----------------------------------

// Setup a case where the defender has a strong defence,
// so we might provoke retaliation.
function test_battle_strong_defence() {
    val can_retaliate = true;
    val flash_attack = false; 
    val chaos_args = move_chaos_mode_arguments(
        defender_can_retaliate = can_retaliate,
        is_flash_attack = flash_attack,
        is_luck = false
    );

    val def_hp = 10;
    val def_defense = 4;
    val def_strength = die_set_get_default_chaotic(); 

    val att_hp = 4;
    val att_defense = 1;
    val att_strength = die_set_get_default_chaotic();

    // ----------------
    log("Test 8= rnd = 1+3, expect Hit with 4 damage, retaliation Miss");
    // ----------------
    var rnd_datas = build_d6_rnd_data([1, 3, 2]); // NOTE: one extra due to "miss" calculation
    var br = calculate_chaos_attack_result(
        0,
        def_hp, def_strength, def_defense,
        att_hp, att_strength, att_defense,
        chaos_args,
        rnd_datas 
         
    );

    // Attack failed
    assert_equals(br.result, battle_result_type.MISS);
    assert_equals(br.defender_lost_hp, 0); // 4 - 4 = 0
    // Retaliation failed
    assert_equals(br.retaliation_result, battle_result_type.ERROR);
    assert_equals(br.attacker_lost_hp, 0);

    // ----------------
    log("Test 2: rnd = 2,3,2,2 expect hit with 5 damage.");
    // ----------------
    rnd_datas = build_d6_rnd_data([2,3,2,2]);
    br = calculate_chaos_attack_result(
        0,
        def_hp, def_strength, def_defense,
        att_hp, att_strength, att_defense,
        chaos_args,
        rnd_datas 
    );
    // Attack success
    assert_equals(br.result, battle_result_type.HIT);
    assert_equals(br.defender_lost_hp, 1); // 5 -4 = 1
    // Retaliation fails
    assert_equals(br.retaliation_result, battle_result_type.MISS); // 4 - 1 +(-7) = -4
    assert_equals(br.attacker_lost_hp, 0);

    // ----------------
    log("Test 6= rnd = 2,6,5,6 expect Hit with 8 damage, retaliation hit");
    // ----------------
    rnd_datas = build_d6_rnd_data([2,6,5,6]);
    br = calculate_chaos_attack_result(
        0,
        def_hp, def_strength, def_defense,
        att_hp, att_strength, att_defense,
        chaos_args,
        rnd_datas
    );
    // Attack success
    assert_equals(br.result, battle_result_type.HIT);
    assert_equals(br.defender_lost_hp, 4); // 8 -4 = 4
    assert_equals(br.retaliation_result, battle_result_type.HIT);
    assert_equals(br.attacker_lost_hp, 3); // 11 - 1 +(-7) = 3

    // ----------------
    log("Test 5= rnd = 3,6,6,6 expect Hit with 9 damage, retaliation kill");
    // ----------------

    rnd_datas = build_d6_rnd_data([3,6,6,6]);
    br = calculate_chaos_attack_result(
        0,
        def_hp, def_strength, def_defense,
        att_hp, att_strength, att_defense,
        chaos_args,
        rnd_datas 
    );
    // Attack success
    assert_equals(br.result, battle_result_type.HIT);
    assert_equals(br.defender_lost_hp, 5); // 9 -4 = 5
    assert_equals(br.retaliation_result, battle_result_type.KILL); // 12 - 1 +(-7) = 4
}

// ----------------------------------
// ELO
// ----------------------------------
function test_elo_draw_1() {

   val player1_rating: integer = 1200;
   val player2_rating: integer = 1200;

    val (p1: integer, p2: integer) = elo.update_chess_ratings_on_draw(
        player1_rating,
        player2_rating
    );

    assert_equals(p1, 1200);
    assert_equals(p2, 1200);
}

function test_elo_draw_2() {

   val player1_rating: integer = 1300;
   val player2_rating: integer = 1200;

    val (p1: integer, p2: integer) = elo.update_chess_ratings_on_draw(
        player1_rating,
        player2_rating
    );

    assert_equals(p1, 1296);
    assert_equals(p2, 1204);
}


function test_elo_win_1() {

   val player1_rating: integer = 1200;
   val player2_rating: integer = 1200;

    val (p1: integer, p2: integer) = elo.update_chess_ratings_on_win(
        player1_rating, // 1 is winner
        player2_rating // Loser
    );

    assert_equals(p1, 1216);
    assert_equals(p2, 1184);
}

function test_elo_win_2() {
   val winner_rating: integer = 1200;
   val loser_rating: integer = 1300;

    val (w: integer, l: integer) = elo.update_chess_ratings_on_win(
        winner_rating, 
        loser_rating 
    );

    assert_equals(w, 1220);
    assert_equals(l, 1280);
}

// ----------------------------------
// Power Of 
// ----------------------------------

// Basic math thes
function test_ten_to_the_power_of() {
    val x = 1.0;
    val result = ten_to_the_power_of(x);
    log("10 ^ 1=" + result.to_text());
    assert_true(result < 10.001);
    assert_true(result > 9.999);
    
    val x2 = 2.0;
    val result2 = ten_to_the_power_of(x2);
    log("10 ^ 2=" + result2.to_text());
    assert_true(result2 < 100.001);
    assert_true(result2 > 99.999);
}

function test_timeout_calc() {

    val game_id = 1;

    // First we need to get the current time

    val less_than_a_minute_ms = 59* 1000;
    val more_than_a_minute_ms = 61* 1000;
    val ten_minutes_ms = 10*60*1000;
    val ten_seconds_ms = 10*1000;

    // --------------------------------------
    // A. Calc during Opp's turn
    // --------------------------------------

    var last_rotation_at: timestamp = 1000000; // 1000 seconds.  This is when OPP's turn began.
    var curr_time_ms = last_rotation_at + more_than_a_minute_ms; // 1061 seconds.

    // Not timed out yet
    var opp_last_heartbeat = last_rotation_at + (2 * 1000); // 1002 seconds
    var otd = opponent_timeout_data(
        is_my_turn = false,
        most_recent_turn_type = turn_type.NEUTRAL_MOVE_1_SKIPPED, // I'm white, and I have finished by turn.
        opp_last_heartbeat = opp_last_heartbeat, // Not abandoned yet, since 59 sec old heartbeat
        last_player_rotation_at = last_rotation_at, // The last time the player rotation was completed 61 sec ago.
        opp_tot_time_left_since_player_rotation_ms = ten_minutes_ms, // The opponent has 10 minutes left when opp's turn (= player rotation) began.
    );
    var (result_abandon, result_timeout) = timeout_calc_all(game_id, curr_time_ms, otd);
    assert_equals(result_abandon, false);
    assert_equals(result_timeout, false);

    // Timed out due to old heartbeat
    opp_last_heartbeat = last_rotation_at; // 1000 seconds
    otd = opponent_timeout_data(
        is_my_turn = false,
        most_recent_turn_type = turn_type.NEUTRAL_MOVE_1_SKIPPED, // I'm white, and I have finished by turn.
        opp_last_heartbeat = opp_last_heartbeat, // Abandoned due to old heartbeat, since 61 sec ago.
        last_player_rotation_at = last_rotation_at, // The last time the player rotation was completed 61 sec ago.
        opp_tot_time_left_since_player_rotation_ms = ten_minutes_ms, // The opponent has 10 minutes left when opp's turn (= player rotation) began.
    );
    var (result_abandon1, result_timeout1) = timeout_calc_all(game_id, curr_time_ms, otd);
    assert_equals(result_abandon1, true);
    assert_equals(result_timeout1, false);

    // Timed out due to total time gone
    opp_last_heartbeat = last_rotation_at + (2 * 1000); // 1002 seconds
    otd = opponent_timeout_data(
        is_my_turn = false,
        most_recent_turn_type = turn_type.NEUTRAL_MOVE_1_SKIPPED, // I'm white, and I have finished by turn.
        opp_last_heartbeat = opp_last_heartbeat, // Not abandoned yet, since 59 sec old heartbeat.
        last_player_rotation_at = last_rotation_at, // The last time the player rotation was completed 61 sec ago.
        opp_tot_time_left_since_player_rotation_ms = less_than_a_minute_ms, // The opponent has 59 sec left when opp's turn (= player rotation) began.
    );
    var (result_abandon2, result_timeout2) = timeout_calc_all(game_id, curr_time_ms, otd);
    assert_equals(result_abandon2, false);
    assert_equals(result_timeout2, true);

    // --------------------------------------
    // B. Calc during My turn
    // --------------------------------------
    // 
    // <..... Opp last heartbeat around here (only create heartbeats during opponent's turn)
    //        But it doesn't matter, since the opponent managed to finish the turn before we 
    //        called ABANDON on him/her.
    // --------------- 900, My turn starts
    //
    //  (Only my heartbeats in here, since it's my job to prove I'm active)
    // 
    // --------------- 1000, Opp turn starts according to the client (But this block has not been processed yet)
    // 
    // 

    // The idea here is that the block containing my move has not been saved to the DB,
    // meaning that the last rotation timestamp, is 100 seconds before, i.e. when MY TURN began.
    var rotation_before_at = 900000; // 900 seconds. This is when MY turn began.

    // Curr time doesn't matter if it's still my turn.
    curr_time_ms = last_rotation_at + more_than_a_minute_ms; // 1061 seconds.

    // Not timed out yet
    opp_last_heartbeat = rotation_before_at - (50 * 1000); // 850 seconds. No heartbeat during MY turn.
    otd = opponent_timeout_data(
        is_my_turn = true,
        most_recent_turn_type = turn_type.WHITE_CARD, // I'm white, and this is the last "turn" in the blockchain.
        opp_last_heartbeat = opp_last_heartbeat, // Not abandoned yet.
        last_player_rotation_at = rotation_before_at, // The last time the player rotation was completed 161 sec ago.
        opp_tot_time_left_since_player_rotation_ms = ten_seconds_ms, // The opponent has 10 seconds left when my turn (= player rotation) began.
    );
    var (result_abandon_m, result_timeout_m) = timeout_calc_all(game_id, curr_time_ms, otd);
    assert_equals(result_abandon_m, false);
    assert_equals(result_timeout_m, false);

    // Abandon won't work during MY turn.
    opp_last_heartbeat = last_rotation_at - (80 * 1000); // 820 seconds
    otd = opponent_timeout_data(
        is_my_turn = true,
        most_recent_turn_type = turn_type.WHITE_CARD,
        opp_last_heartbeat = opp_last_heartbeat, // Even though old heartbeat was 80 sec before turn switch, it doesn't matter.
        last_player_rotation_at = rotation_before_at, // The last time the player rotation was completed 161 sec ago.
        opp_tot_time_left_since_player_rotation_ms = ten_seconds_ms, // The opponent has 10 seconds left when my turn (= player rotation) began.
    );
    var (result_abandon_m1, result_timeout_m1) = timeout_calc_all(game_id, curr_time_ms, otd);
    assert_equals(result_abandon_m1, false);
    assert_equals(result_timeout_m1, false);

    // Timed out due to total time gone
    opp_last_heartbeat = rotation_before_at - (50 * 1000); // 850 seconds. No heartbeat during MY turn.
    otd = opponent_timeout_data(
        is_my_turn = true,
        most_recent_turn_type = turn_type.WHITE_CARD,
        opp_last_heartbeat = opp_last_heartbeat, // Not timed out yet, since 59 sec old heartbeat.
        last_player_rotation_at = rotation_before_at, // The last time the player rotation was completed 161 sec ago.
        opp_tot_time_left_since_player_rotation_ms = -1, // The opponent has no time left 
    );
    var (result_abandon_m2, result_timeout_m2) = timeout_calc_all(game_id, curr_time_ms, otd);
    assert_equals(result_abandon_m2, false);
    assert_equals(result_timeout_m2, true);
}

// ----------------------------------
// Game
// ----------------------------------

function test_full_game() {

    // ------------
    // Check if DB is empty
    // ------------
    val players: list<rowid> = player@* {} (.rowid);
    assert_equals(players.size(), 0);


    // ------------
    log("Create the players");
    // ------------
     
    // All in one
    rell.test.tx(create_player("Alice")).sign(rell.test.keypairs.alice).run();
    rell.test.tx(create_player("Bob")).sign(rell.test.keypairs.bob).run();
    rell.test.tx(create_player("Charlie")).sign(rell.test.keypairs.charlie).run();
    rell.test.tx(create_player("Dave")).sign(rell.test.keypairs.dave).run();

    // ------------
    log("Check if players are created");
    // ------------
    val players_after: list<rowid> = player@* {} (.rowid);
    assert_equals(players_after.size(), 4);


    rell.test.tx(enter_lobby("Bob",     "SPEED_5_CLASSIC")).sign(rell.test.keypairs.bob).run();
    rell.test.tx(enter_lobby("Charlie", "SPEED_10_CLASSIC")).sign(rell.test.keypairs.charlie).run();
    rell.test.tx(enter_lobby("Dave",    "SPEED_5_CLASSIC")).sign(rell.test.keypairs.dave).run();

    // Alice looks for 10 min match
    val match_10_mins = consume_lobby_entry(rell.test.keypairs.alice.pub, 0, "SPEED_10_CLASSIC");
    // ALice finds Charlie
    val opp_player: pubkey = rell.test.keypairs.charlie.pub;
    assert_equals(match_10_mins, opp_player);

    // ------------
    log("Alice creates a 10 min game with Charlie");
    // ------------
    rell.test.tx(create_game_via_lobby(opp_player, "SPEED_10_CLASSIC")).sign(rell.test.keypairs.alice).run();

    // ------------
    log("Alice looks for the game");
    // ------------
    val found_game: in_game_result? = in_game(rell.test.keypairs.alice.pub);
    assert_not_null(found_game);
    val the_game = found_game;

    // If we need the game entity 
    val g: game = (g: game) @ {g.rowid == rowid(the_game.game_rowid) };

    val alice_white = the_game.is_white;
    var alice_color = "black";
    var white_player = rell.test.keypairs.charlie;
    var black_player = rell.test.keypairs.alice;
    if (alice_white) {
        alice_color = "white";
        white_player = rell.test.keypairs.alice;
        black_player = rell.test.keypairs.charlie;
    }


    assert_equals(the_game.game_type, game_type.SPEED_10_CLASSIC);
    assert_equals(the_game.opponent_pubkey, opp_player);
    assert_equals(the_game.opponent_name, "Charlie");
    assert_equals(the_game.opponent_elo, 1200);
    assert_equals(the_game.curr_turn_nr, 0);

    // ------------
    log("New Game: Verify pieces");
    // ------------
    val pieces = get_my_living_pieces(the_game.game_rowid, true);
    assert_equals(pieces.size(), 16);
    var out_str = alice_color + " pieces: ";
    for (p in pieces) {
        assert_true(p.is_alive);
        assert_equals(p.color_str,"white");
        assert_true(p.active_type_str == p.original_type_str);
        out_str += p.active_type_str + "=" + p.position + "("+ p.remaining_hit_points + "), ";
    }

    log(out_str);

    // Before the game begins, we haven't seen any turns, so we say that the [last_seen_turn] is 0.
    // But, remember that there IS a turn in the database with number 0 (= the FRESH_GAME turn).
    var last_seen_turn = 0; 
    var fetching_rotation_nr = 1;

    // +++++++++++++++++++++++++++++++++++++++++ White Move 1 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 8= r  kn b  q  k  b  kn r  
    // 7= p  p  p  p  p  p  p  p  // <- Lower case for black
    // 6= .  .  .  .  .  .  .  .
    // 5= .  .  .  .  .  .  .  .
    // 4= .  .  .  .  .  .  .  .
    // 3= .  .  .  .  .  .  .  .
    // 2= P  P  P  P  P  P  P  P // <- Upper case for white
    // 1= R  Kn B  Q  K  B  Kn R
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------
    // "." means free square
    // "-" marks the "prev" position of a piece
    // "+" marks the "next" position of a piece (after move or capture)
    // "@" marks the position where a piece will "appear" (magically, not result of a move)
    // "x" marks the position of a piece that was captured (only relevant for en passant)

    // --------------------
    // White Hand
    // --------------------
    // The cards in white's hand are (in the "draw order")
    // 1. FROG
    // 2. WALL
    // 3. PORTAL
    // 4. JUMP
    // 5. RESURRECT
    // --------------------
    // Black Hand
    // --------------------
    // The cards in black's hand are (in the "draw order")
    // 1. KNIGHTED
    // 2. PORTAL
    // 3. DOUBLE_MOVE
    // 4. KNIGHTED
    // 5. RESURRECT

    // Since WHITE begins, it's BLACK who fetches data now
    var recent_actions: player_rotation_actions? = get_opponents_recent_actions(black_player.pub, the_game.game_rowid, fetching_rotation_nr, last_seen_turn);
    assert_null(recent_actions); // Nothing happened yet so we should get empty

    // But if we ask for timeout data we always get that
    recent_actions = get_opponents_recent_actions(black_player.pub, the_game.game_rowid, fetching_rotation_nr, last_seen_turn, true);
    assert_not_null(recent_actions);
    assert_equals(recent_actions.curr_turn_nr, 0); // No turn yet
    assert_false(recent_actions.rotate_color);
    assert_null(recent_actions.card_played_data);
    assert_not_null(recent_actions.timeout_data);
    assert_false(recent_actions.timeout_data.is_my_turn); // This is black asking, but white should bbegin
    assert_false(recent_actions.timeout_data.opp_timeout); // Not timed out yet

    // --------------------
    // Failed White Cards
    // --------------------
    // First we try a few invalid cards, to make sure the validation works.

    var minimal_game: minimal_game_result? = minimal_game_data_get(white_player.pub);
    require (minimal_game != null, "Player is not in a game");
    var reverted_list: list<card_enchantment_reverted> = card_enchantment_revert_timed_out(minimal_game.game, minimal_game.player_game);
    require (reverted_list.size() == 0, "Shouldn't start with timed out enchantments");

    log("Turn 1(1): Card Fail A. No picks for FROG");
    var crd_data = card_played_data(
        card_type_str = "FROG",
        card_order_number = 1,
        card_picks = []
    );
    var failed_card = assert_fails(card_play_inner_core(minimal_game, the_game.game_rowid, last_seen_turn, crd_data, list<rnd_data>(), reverted_list,
        * // Note, this star is what makes it work.
    ));
    val expected_no_pick_msg: text = "Expected 1 picks for card FROG but got 0";
    assert_true(failed_card.message.starts_with(expected_no_pick_msg));

    log("Turn 1(1): Card Fail B. Out of board pick for FROG");
    crd_data = card_played_data(
        card_type_str = "FROG",
        card_order_number = 1,
        card_picks = [64] // Out of board
    );
    failed_card = assert_fails(card_play_inner_core(minimal_game, the_game.game_rowid, last_seen_turn, crd_data, list<rnd_data>(), reverted_list,
        * // Note, this star is what makes it work.
    ));
    val expected_out_of_board_pick: text = "Pick at pos 0 is out of board.";
    log("Err:" + failed_card.message);
    assert_true(failed_card.message.starts_with(expected_out_of_board_pick));

    log("Turn 1(1)= Card Fail C. Free square pick for FROG");

    crd_data = card_played_data(
        card_type_str = "FROG",
        card_order_number = 1,
        card_picks = [18] // = c3, free square
    );
    failed_card = assert_fails(card_play_inner_core(minimal_game, the_game.game_rowid, last_seen_turn, crd_data, list<rnd_data>(), reverted_list,
        * // Note, this star is what makes it work.
    ));
    val expected_must_be_piece_msg: text = "Expected pick at pos 0 to be type PIECE_NON_KING_SQUARE but found a free square at position 18.";
    assert_true(failed_card.message.starts_with(expected_must_be_piece_msg));

    // --------------------
    // /Failed White Cards
    // --------------------

    log("Turn 1(1): White plays FROG (on black rook at a8)");
    val a8 = 56; // Turns black rook into frog
    crd_data = card_played_data(
        card_type_str = "FROG",
        card_order_number = 1,
        card_picks = [a8] 
    );
    rell.test.tx(play_card(the_game.game_rowid, last_seen_turn, crd_data, list<rnd_data>())).sign(white_player).run();

    // Try to fetch the card.
    recent_actions = get_opponents_recent_actions(black_player.pub, the_game.game_rowid, fetching_rotation_nr, last_seen_turn);
    assert_not_null(recent_actions);
    assert_equals(recent_actions.curr_turn_nr, 1);
    assert_false(recent_actions.rotate_color);
    assert_not_null(recent_actions.card_played_data);
    assert_equals(recent_actions.card_played_data.card_type_str, "FROG");
    assert_equals(recent_actions.card_played_data.card_order_number, 1);
    assert_equals(recent_actions.card_played_data.card_picks[0], a8);

    last_seen_turn += 1;
    var m_type = move_type.NORMAL.name;

    // --------------------
    // Failed White moves
    // --------------------
    // 8= f  kn b  q  k  b  kn r // <--- next: Rook at a8 is now a frog
    // 7= p  p  p  p  p  p  p  p  
    // 6= .  .  .  .  .  .  .  .
    // 5= .  .  .  .  .  .  .  .
    // 4= .  .  .  .  .  .  .  .
    // 3= .  .  +  .  .  .  .  . // <--- next: Knight b2 -> c3
    // 2= P  P  P  P  P  P  P  P 
    // 1= R  Kn B  Q  K  B  Kn R // <--- next: Knight b2 -> c3
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------
    // First we try a few invalid moves, to make sure the validation works.

    log("Turn 1(2): Move Fail A. No piece at position");
    val wrong_orig_pos = 22; // Nothing on this position
    val wrong_to_pos = 23; 

    var m_args = move_arguments(
        from_position = wrong_orig_pos, // <-- Wrong
        to_position = wrong_to_pos,  // <-- Wrong
        piece_type_str = "BISHOP", // <-- Ok
        given_is_knighted = false, 
        given_is_enchanted_jumper = false);

    val check_args_nothing = move_check_arguments(
        is_check = false, 
        is_checkmate = false, 
        is_stalemate = false,
        is_insufficient_mating_material = false,
        random_seed = null,
        seed_signature = null);

    var failed_move = assert_fails(move_peaceful_inner(white_player.pub, the_game.game_rowid, last_seen_turn, m_type, m_args, null, null, check_args_nothing,
        * // Note, this star is what makes it work.
        ));
    val expected_wrong_pos: text = "No piece at position " + wrong_orig_pos;
    assert_true(failed_move.message.starts_with(expected_wrong_pos));

    log("Turn 1(2): Move Fail B. Wrong piece_type at position");
    val knight_orig_pos = 1; // b1 (correct)
    val knight_to_pos = 18;  // c3 (Valid move)

    m_args = move_arguments(
        from_position = knight_orig_pos, // <-- Ok
        to_position = knight_to_pos, // <-- Ok
        piece_type_str = "BISHOP",  // <-- Wrong
        given_is_knighted = false, 
        given_is_enchanted_jumper = false); 

    failed_move = assert_fails(move_peaceful_inner(white_player.pub, the_game.game_rowid, last_seen_turn, m_type, m_args, null, null, check_args_nothing,
        * // Note, this star is what makes it work.
    ));
    val expected_wrong_type: text = "Expected piece to have active type KNIGHT but got BISHOP";
    assert_true(failed_move.message.starts_with(expected_wrong_type));

    log("Turn 1(2): Move Fail C. Invalid move pattern");
    val knight_to_wrong_pos = 17;  // b3 (Invalid move)

    m_args = move_arguments(
        from_position = knight_orig_pos, // <-- Ok
        to_position = knight_to_wrong_pos, // <-- Wrong
        piece_type_str = "KNIGHT", // <-- Ok
        given_is_knighted = false, 
        given_is_enchanted_jumper = false);

    failed_move = assert_fails(move_peaceful_inner(white_player.pub, the_game.game_rowid, last_seen_turn, m_type, m_args, null, null, check_args_nothing,
        * // Note, this star is what makes it work.
    ));
    log(failed_move.message);
    val expected_wrong_move: text = "Illegal move";
    assert_true(failed_move.message.starts_with(expected_wrong_move));


    log("Turn 1(2): Move Fail D. Bishop cannot move to own piece!");
    val bishop_orig_pos = 2; // c1 (correct)
    val bishop_to_pos = 9; // Vaild move pattern, but pawn here, cannot move this way

    m_args = move_arguments(
        from_position = bishop_orig_pos, // <-- Ok
        to_position = bishop_to_pos, // <-- Ok, but occupied 
        piece_type_str = "BISHOP",  // <-- Ok
        given_is_knighted = false, 
        given_is_enchanted_jumper = false);

    failed_move = assert_fails(move_peaceful_inner(white_player.pub, the_game.game_rowid, last_seen_turn, m_type, m_args, null, null, check_args_nothing,
        * // Note, this star is what makes it work.
    ));
    val expected_move_on_friend: text = "Illegal move";
    assert_true(failed_move.message.starts_with(expected_move_on_friend));

    // --------------------
    // /Failed White moves
    // --------------------

    log("Turn 1(2): White makes a valid move Kn b1->c3");

    m_args = move_arguments(
        from_position = knight_orig_pos, // <-- Ok
        to_position = knight_to_pos, // <-- Ok
        piece_type_str = "KNIGHT",  // <-- Ok
        given_is_knighted = false, 
        given_is_enchanted_jumper = false);

    rell.test.tx(move_peaceful(the_game.game_rowid, last_seen_turn, m_type, m_args, null, null, check_args_nothing)).sign(white_player).run();

    log ("Turn 1(3): Skip neutral.");
    val temp_last_seen_turn = last_seen_turn + 1; // Don't want to update the real one, since we should fetch two moves soon.

    // --------------------
    // Try to fetch the two moves.
    // --------------------
    recent_actions = get_opponents_recent_actions(black_player.pub, the_game.game_rowid, fetching_rotation_nr, last_seen_turn);
    assert_not_null(recent_actions);
    assert_equals(recent_actions.curr_turn_nr, 3);
    assert_true(recent_actions.rotate_color);

    // Primary move
    var primary_move: move_full_data? = recent_actions.primary_move;
    assert_not_null(primary_move);
    var m_data: opponents_move_data? = primary_move.m_data;
    assert_not_null(m_data);
    assert_equals(m_data.from_position, knight_orig_pos);
    assert_equals(m_data.to_position, knight_to_pos);
    assert_false(m_data.is_castle);
    assert_false(m_data.given_is_knighted);
    assert_false(m_data.given_is_enchanted_jumper);

    // Check/Stale/Mate
    var check_info: check_data = primary_move.check_data;
    assert_false(check_info.is_check);
    assert_false(check_info.is_checkmate);
    assert_false(check_info.is_stalemate);

    // Extra move
    assert_null(recent_actions.extra_move);


    last_seen_turn += 1;
    last_seen_turn += 1;
  

    // +++++++++++++++++++++++++++++++++++++++++ BLack Move 2 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 8= f  kn b  q  k  b  kn r
    // 7= p  p  p  p  p  p  p  p // <--- next: pawn a7 -> a5
    // 6= .  .  .  .  .  .  .  . 
    // 5= +  .  .  .  .  .  .  . // <--- next: pawn a7 -> a5
    // 4= .  .  .  .  .  .  .  .
    // 3= .  .  Kn .  .  .  .  . // <--- prev: Knight b2 -> c3
    // 2= P  P  P  P  P  P  P  P
    // 1= R  -  B  Q  K  B  Kn R // <--- prev: Knight b2 -> c3
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------
    log ("Turn 2(4): Black skips spell");
    rell.test.tx(skip_card(the_game.game_rowid, last_seen_turn)).sign(black_player).run();
    last_seen_turn += 1;
    fetching_rotation_nr += 1;

    log ("Turn 2(5): Black moves pawn a7->a5");
    val black_move_1_from = 48; // a7
    val black_move_1_to = 32; // a5 = Pawn double move 

    m_args = move_arguments(
        from_position = black_move_1_from, 
        to_position = black_move_1_to, 
        piece_type_str = "PAWN", 
        given_is_knighted = false, 
        given_is_enchanted_jumper = false); 

    rell.test.tx(move_peaceful(the_game.game_rowid, last_seen_turn, m_type, m_args, null, null, check_args_nothing)).sign(black_player).run();
    last_seen_turn += 1;

    log ("Turn 2(6): Skip neutral.");
    last_seen_turn += 1;

    // +++++++++++++++++++++++++++++++++++++++++ White Move 3 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 8= f  kn b  q  k  b  kn r
    // 7= -  p  p  p  p  p  p  p // <--- prev: pawn a7 -> a5
    // 6= .  .  .  .  .  .  .  .
    // 5= p  .  .  .  .  .  .  . // <--- prev: pawn a7 -> a5
    // 4= .  .  .  .  .  .  .  .
    // 3= .  .  Kn .  .  .  +  . // <--- next: pawn g2 -> g3 
    // 2= P  P  P  P  P  P  P  P 
    // 1= R  .  B  Q  K  B  Kn R
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------
    log ("Turn 3(7): White skips spell");
    rell.test.tx(skip_card(the_game.game_rowid, last_seen_turn)).sign(white_player).run();
    last_seen_turn += 1;
    fetching_rotation_nr += 1;

    log("Turn 3(8): White makes a valid move Pawn g2 -> g3");

    m_args = move_arguments(
        from_position = 14,
        to_position = 22,
        piece_type_str = "PAWN", 
        given_is_knighted = false, 
        given_is_enchanted_jumper = false);

    rell.test.tx(move_peaceful(the_game.game_rowid, last_seen_turn, m_type, m_args, null, null, check_args_nothing)).sign(white_player).run();
    last_seen_turn += 1;

    log ("Turn 3(9): Skip neutral.");
    last_seen_turn += 1;

    // +++++++++++++++++++++++++++++++++++++++++ BLack Move 4 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 8= f  kn b  q  k  b  kn r
    // 7= .  p  p  p  p  p  p  p
    // 6= .  .  .  .  .  .  .  .
    // 5= p  .  .  .  .  .  .  . // <--- next: pawn a5 -> a4
    // 4= +  .  .  .  .  .  .  . // <--- next: pawn a5 -> a4
    // 3= .  .  Kn .  .  .  P  . // <--- prev: pawn g2 -> g3 
    // 2= P  P  P  P  P  P  -  P // <--- card: turn c2 into a knight
    // 1= R  .  B  Q  K  B  Kn R
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------
    log("Turn 4(10): Black plays KNIGHTED on c2 pawn (A blunder since this is helping white).");
    val c2 = 10;
    var card_picks_knighted = [c2]; // Turns WHITE's(!) c2 pawn into knight
    crd_data = card_played_data(
        card_type_str = "KNIGHTED",
        card_order_number = 1,
        card_picks = card_picks_knighted,
    );
    rell.test.tx(play_card(the_game.game_rowid, last_seen_turn, crd_data, list<rnd_data>())).sign(black_player).run();
    last_seen_turn += 1;
    fetching_rotation_nr += 1;

    // --------------------
    // Failed Black moves
    // --------------------
    // First we try to move the rook link usually, but its ACTIVE TYPE is a frog, so shouldn't work.
    // It's only been a frog 2 turns, to the enchantment has not yet timed out.
    log ("Turn 4(11): Failed Black Rook (=actually a Frog) moves a8->a6");
    val rook_to_wrong_pos = 40;  // a6 (Cannot move two steps since is frog)

    m_args = move_arguments(
        from_position = a8,
        to_position = rook_to_wrong_pos, // <-- Wrong, still a frog 
        piece_type_str = "ROOK",  // <-- Wrong, still a frog 
        given_is_knighted = false, 
        given_is_enchanted_jumper = false);
    
    failed_move = assert_fails(move_peaceful_inner(black_player.pub, the_game.game_rowid, last_seen_turn, m_type, m_args, null, null, check_args_nothing,
        * // Note, this star is what makes it work.
    ));
    val expected_rook_vs_frog = "Expected piece to have active type FROG but got ROOK";
    log("Err:" + failed_move.message);
    assert_true(failed_move.message.starts_with(expected_rook_vs_frog));

    // If we call the frog a FROG, can it move as a rook?
    log ("Turn 4(11): Failed Black Frog moves a8->a6");

    m_args = move_arguments(
        from_position = a8,
        to_position = rook_to_wrong_pos, // <-- Wrong
        piece_type_str = "FROG",  // <-- Ok
        given_is_knighted = false, 
        given_is_enchanted_jumper = false);
 
    failed_move = assert_fails(move_peaceful_inner(black_player.pub, the_game.game_rowid, last_seen_turn, m_type, m_args, null, null, check_args_nothing,
        * // Note, this star is what makes it work.
    ));
    log(failed_move.message);
    assert_true(failed_move.message.starts_with(expected_wrong_move));

    // --------------------
    // /Failed Black moves
    // --------------------

    log ("Turn 4(11): Black moves pawn a5->a4");
    val a5 = 32; 
    val a4 = 24; 

    m_args = move_arguments(
        from_position = a5, // <-- Ok
        to_position = a4, // <-- Ok
        piece_type_str = "PAWN",  // <-- Ok
        given_is_knighted = false, 
        given_is_enchanted_jumper = false);

    rell.test.tx(move_peaceful(the_game.game_rowid, last_seen_turn, m_type, m_args, null, null, check_args_nothing)).sign(black_player).run();
    last_seen_turn += 1;
    
    log ("Turn 4(12): Skip neutral.");
    last_seen_turn += 1;

    // +++++++++++++++++++++++++++++++++++++++++ White Move 5 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 8= f  kn b  q  k  b  kn r
    // 7= .  p  p  p  p  p  p  p
    // 6= .  .  .  .  .  .  .  .
    // 5= -  .  .  .  .  .  .  . // <--- prev: pawn a5 -> a4
    // 4= P  +  .  .  .  .  .  . // <--- next: pawn b2 -> b4
    // 3= .  .  Kn .  .  .  P  .
    // 2= P  P  Pk P  P  P  .  P // <--- next: pawn b2 -> b4
    // 1= R  .  B  Q  K  B  Kn R
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------

    log("Turn 5(13): White skips spell.");
    rell.test.tx(skip_card(the_game.game_rowid, last_seen_turn)).sign(white_player).run();
    last_seen_turn += 1;
    fetching_rotation_nr += 1;

    log("Turn 5(14): White makes a valid move Pawn b2 -> b4. Opens for en passant.");
    val b2 = 9;
    val b4 = 25;

    m_args = move_arguments(
        from_position = b2, // <-- Ok
        to_position = b4, // <-- Ok
        piece_type_str = "PAWN",  // <-- Ok
        given_is_knighted = false, 
        given_is_enchanted_jumper = false);

    rell.test.tx(move_peaceful(the_game.game_rowid, last_seen_turn, m_type, m_args, null, null, check_args_nothing)).sign(white_player).run();
    last_seen_turn += 1;

    log ("Turn 5(15): Skip neutral.");
    last_seen_turn += 1;

    // +++++++++++++++++++++++++++++++++++++++++ BLack Move 6 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 8= f  kn b  q  k  b  kn r
    // 7= .  p  p  p  p  p  p  p
    // 6= .  .  .  .  .  .  .  .
    // 5= .  .  .  .  .  .  .  .
    // 4= p  P  .  .  .  .  .  . // <--- next: pawn a4 x b3 En passant
    // 3= .  +  Kn .  .  .  P  . // <--- next: pawn a4 x b3 En passant
    // 2= P  -  Pk P  P  P  .  P // <--- prev: pawn b2 -> b4
    // 1= R  .  B  Q  K  B  Kn R
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------

    log ("Turn 6(16): Black skips spell");
    rell.test.tx(skip_card(the_game.game_rowid, last_seen_turn)).sign(black_player).run();
    last_seen_turn += 1;
    fetching_rotation_nr += 1;

    log ("Turn 6(17): Black captuers pawn a4->b3, via en passant");
    val b3 = 17;

    m_args = move_arguments(
        from_position = a4, 
        to_position = b3, // <-- En passant
        piece_type_str = "PAWN",  
        given_is_knighted = false, 
        given_is_enchanted_jumper = false);


    // Attack data, mandatory for attacks.
    var att_args = move_attack_arguments (
        attacked_position = b3, 
        attack_result_type_str = "KILL", 
        defender_defense_points = 3, 
        damage_points = 7 
    );

    rell.test.tx(move_attack(the_game.game_rowid, last_seen_turn, m_type, m_args, att_args, list<rnd_data>(), check_args_nothing)).sign(black_player).run();
    
    log ("Turn 6(18): Skip neutral.");
    val temp_last_seen_turn2 = last_seen_turn + 1; // Don't want to update the real one, since we should fetch two moves soon.

    // --------------------
    // Try to fetch the two moves.
    // --------------------
    recent_actions = get_opponents_recent_actions(white_player.pub, the_game.game_rowid, fetching_rotation_nr, last_seen_turn);
    assert_not_null(recent_actions);
    assert_equals(recent_actions.curr_turn_nr, temp_last_seen_turn2 + 1);
    assert_true(recent_actions.rotate_color);

    // Primary move
    primary_move = recent_actions.primary_move;
    assert_not_null(primary_move);
    m_data = primary_move.m_data;
    assert_not_null(m_data);
    assert_equals(m_data.from_position, a4);
    assert_equals(m_data.to_position, b3);
    assert_false(m_data.is_castle);
    assert_false(m_data.given_is_knighted);
    assert_false(m_data.given_is_enchanted_jumper);
    var fetched_att_args: move_attack_arguments? = primary_move.att_args;
    assert_not_null(fetched_att_args);
    assert_equals(fetched_att_args.attacked_position, b3); // <-- Not the same as to_position!
    assert_equals(fetched_att_args.attack_result_type_str, "KILL");
    assert_equals(fetched_att_args.defender_defense_points, 3);
    assert_equals(fetched_att_args.damage_points, 7); 

    // Extra move
    assert_null(recent_actions.extra_move);

    last_seen_turn += 1;
    last_seen_turn += 1;

    // +++++++++++++++++++++++++++++++++++++++++ White Move 7 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 8= f  kn b  q  k  b  kn r
    // 7= .  p  p  p  p  p  p  p
    // 6= .  .  .  .  .  @  .  . // <--- next: Portal travel a2 -> f6
    // 5= .  .  .  .  .  .  .  .
    // 4= -  x  .  .  .  .  .  . // <--- prev: Pawn on a5 is captured
    // 3= .  p  Kn .  .  .  P  . // <--- prev: pawn a4 x b3 En passant
    // 2= P  .  Pk P  P  P  .  P // <--- next: Portal travel a2->f6
    // 1= R  .  B  Q  K  B  Kn R
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------

    log("Turn 7(19): White playes PORTAL (a2->f6)");

    // Bit tricky to figure out what the random number should be to put the exit at f6.
    val a2 = 8;
    val f6 = 45;
    var min_portal_empty_squares = 0;
    var total_empty_squares_on_black_side = 17; // One extra since one pawn crossed to other side
    var max_portal_empty_squares = total_empty_squares_on_black_side - 1;
    var portal_rnd_result = 13; // f6. Start counting from rank 5. 0->7 (=8 steps). Rank 4. 8-> 13 (6 steps)
    var portal_rnd_data = rnd_data(
        result = portal_rnd_result, 
        min = min_portal_empty_squares, 
        max = max_portal_empty_squares
    );
    var rnds: list<rnd_data> = [portal_rnd_data];

    crd_data = card_played_data(
        card_type_str = "PORTAL",
        card_order_number = 3,
        card_picks = [a2, f6],
    );
    rell.test.tx(play_card(the_game.game_rowid, last_seen_turn, crd_data, rnds)).sign(white_player).run();
    last_seen_turn += 1;
    fetching_rotation_nr += 1;

    log ("Turn 7(20): White must skip move (due to portal).");
    var end_args = move_end_events_arguments(
        used_portals = [ a2 ], // <-- Portal a2 was used
        resurrection_pos = null, 
        promotions = list<integer>()
    );
    rell.test.tx(skip_primary_move(the_game.game_rowid, last_seen_turn, m_type, check_args_nothing, end_args)).sign(white_player).run();
    last_seen_turn += 1;

    log ("Turn 7(21): Skip neutral.");
    last_seen_turn += 1;

    // +++++++++++++++++++++++++++++++++++++++++ Black Move 8 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 8= r  kn b  q  k  b  kn r // <--- next: Frog -> Rook (enchantment removed)
    // 7= .  p  p  p  p  p  p  p
    // 6= .  .  .  .  .  P  .  . // <--- prev: Pawn moved through new portal a2->f6
    // 5= .  .  .  .  .  .  .  .
    // 4= .  .  .  .  .  .  .  . 
    // 3= .  p  Kn .  .  .  P  .
    // 2= -  .  Pk P  P  P  .  P // <--- prev: Pawn moved through new portal a2->f6
    // 1= R  .  B  Q  K  B  Kn R // <--- next: Rook a8 x a1 (shouldn't cause resurrection)
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------

    // Let's check if the Pawn at a2 moved? 
    val what_a2: piece_living_data? = piece_get_living_data_from_pos(g, 8);
    if (what_a2 != null) {
        log("what at a2: " + what_a2.active_type);
    } else {
        log("what at a2: null");
    }

    // Let's check if there popped up a Pawn at g3? 
    val what_f6: piece_living_data? = piece_get_living_data_from_pos(g, 45);
    if (what_f6 != null) {
        log("what at f6: " + what_f6.active_type);
    } else {
        log("what at f6: null");
    }

    log("Turn 8(22): Black plays RESURRECT");
    crd_data = card_played_data(
        card_type_str = "RESURRECT",
        card_order_number = 5,
        card_picks = [],
    );
    rell.test.tx(play_card(the_game.game_rowid, last_seen_turn, crd_data, list<rnd_data>())).sign(black_player).run();
    last_seen_turn += 1;
    fetching_rotation_nr += 1;

    // The A8 rook was turned into a FROG turn 1, but this enchantment should have been removed by now.
    log ("Turn 8(23): Black captuers rook a8->a1");
    val a1 = 0;

    m_args = move_arguments(
        from_position = a8, 
        to_position = a1, 
        piece_type_str = "ROOK",  
        given_is_knighted = false, 
        given_is_enchanted_jumper = false);

    // Attack data, mandatory for attacks.
    att_args = move_attack_arguments (
        attacked_position = a1, 
        attack_result_type_str = "KILL", 
        defender_defense_points = 3, 
        damage_points = 7 
    );

    rell.test.tx(move_attack(the_game.game_rowid, last_seen_turn, m_type, m_args, att_args, list<rnd_data>(), check_args_nothing)).sign(black_player).run();
    last_seen_turn += 1;

    log ("Turn 8(24): Skip neutral.");
    last_seen_turn += 1;

    // +++++++++++++++++++++++++++++++++++++++++ White Move 9 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 8= -  kn b  q  k  b  kn r // <--- prev: Rook a8 x a1 (shouldn't cause resurrection)
    // 7= .  p  p  p  p  p  p  p
    // 6= .  .  .  .  .  P  .  .
    // 5= .  .  .  .  .  .  .  .
    // 4= .  .  .  .  .  .  .  . 
    // 3= .  p  Kn .  .  .  P  . // <--- next: Pawn takes on c2 x b3 (shouldn't cause resurrection)
    // 2= .  .  Pk P  P  P  .  P // <--- next: Pawn takes on c2 x b3 (shouldn't cause resurrection)
    // 1= r  .  B  Q  K  B  Kn R // <--- prev: Rook a8 x a1 (shouldn't cause resurrection)
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------

    log("Turn 9(25): White also plays RESURRECT.");
    crd_data = card_played_data(
        card_type_str = "RESURRECT",
        card_order_number = 5,
        card_picks = [],
    );
    rell.test.tx(play_card(the_game.game_rowid, last_seen_turn, crd_data, list<rnd_data>())).sign(white_player).run();
    last_seen_turn += 1;
    fetching_rotation_nr += 1;

    log ("Turn 9(26): White captuers pawn c2->b3, but no resurrection (Note: pawn is KNIGHTED).");

    m_args = move_arguments(
        from_position = c2, 
        to_position = b3, 
        piece_type_str = "PAWN",  
        given_is_knighted = true, 
        given_is_enchanted_jumper = false);


    // Attack data, mandatory for attacks.
    att_args = move_attack_arguments (
        attacked_position = b3, 
        attack_result_type_str = "KILL", 
        defender_defense_points = 3, 
        damage_points = 7 
    );

    rell.test.tx(move_attack(the_game.game_rowid, last_seen_turn, m_type, m_args, att_args, list<rnd_data>(), check_args_nothing)).sign(white_player).run();
    last_seen_turn += 1;
    
    log ("Turn 9(27): Skip neutral.");
    last_seen_turn += 1;

    // +++++++++++++++++++++++++++++++++++++++++ Black Move 10 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 8= .  kn b  q  k  b  kn r
    // 7= .  p  p  p  p  p  p  p // <--- next: Pawn g7 -> g6
    // 6= .  .  .  .  .  P  +  . // <--- next: Pawn g7 -> g6
    // 5= .  .  .  .  .  .  .  .
    // 4= .  .  .  .  .  .  .  . 
    // 3= .  Pk Kn .  .  .  P  . // <--- prev: Pawn takes on c2 x b3 (shouldn't cause resurrection)
    // 2= .  .  -  P  P  P  .  P // <--- prev: Pawn takes on c2 x b3 (shouldn't cause resurrection) 
    // 1= r  .  B  Q  K  B  Kn R  
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------

    log ("Turn 10(28): Black skips spell");
    rell.test.tx(skip_card(the_game.game_rowid, last_seen_turn)).sign(black_player).run();
    last_seen_turn += 1;
    fetching_rotation_nr += 1;

    log ("Turn 10(29): Black moves pawn g7->g6, to avoid being taken.");
    val g7 = 54; 
    val g6 = 46; 

    m_args = move_arguments(
        from_position = g7, // <-- Ok
        to_position = g6, // <-- Ok
        piece_type_str = "PAWN",  // <-- Ok
        given_is_knighted = false, 
        given_is_enchanted_jumper = false);

    rell.test.tx(move_peaceful(the_game.game_rowid, last_seen_turn, m_type, m_args, null, null, check_args_nothing)).sign(black_player).run();
    last_seen_turn += 1;
    
    log ("Turn 10(30): Skip neutral.");
    last_seen_turn += 1;

    // +++++++++++++++++++++++++++++++++++++++++ White Move 11 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 8= .  kn b  q  k  b  kn r
    // 7= .  p  p  p  p  p  -  p // <--- prev: Pawn g7 -> g6
    // 6= .  .  .  .  .  P  p  . // <--- prev: Pawn g7 -> g6
    // 5= .  .  .  .  .  .  .  .
    // 4= +  .  .  .  .  .  .  . // <--- next: Knight c3 -> a4
    // 3= .  Pk Kn .  .  .  P  . // <--- next: Knight c3 -> a4
    // 2= .  .  .  P  P  P  .  P 
    // 1= r  .  B  Q  K  B  Kn R  
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------

    log("Turn 11(31): White skips spell.");
    rell.test.tx(skip_card(the_game.game_rowid, last_seen_turn)).sign(white_player).run();
    last_seen_turn += 1;
    fetching_rotation_nr += 1;

    log("Turn 11(32): White makes a valid move Knight c3 -> a4. Blocks rook's escape.");
    val c3 = 18;

    m_args = move_arguments(
        from_position = c3, // <-- Ok
        to_position = a4, // <-- Ok
        piece_type_str = "KNIGHT",  // <-- Ok
        given_is_knighted = false, 
        given_is_enchanted_jumper = false);

    rell.test.tx(move_peaceful(the_game.game_rowid, last_seen_turn, m_type, m_args, null, null, check_args_nothing)).sign(white_player).run();
    last_seen_turn += 1;

    log ("Turn 11(33): Skip neutral.");
    last_seen_turn += 1;

    // +++++++++++++++++++++++++++++++++++++++++ Black Move 12 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 8= .  kn b  q  k  b  kn r
    // 7= .  p  p  p  p  p  .  p // <--- next: Pawn e7 -> e6
    // 6= .  .  .  .  +  P  p  . // <--- next: Pawn e7 -> e6
    // 5= .  .  .  .  .  .  .  . 
    // 4= Kn .  .  .  .  .  .  . // <--- prev: Knight c3 -> a4
    // 3= .  Pk -  .  .  .  P  . // <--- prev: Knight c3 -> a4
    // 2= .  .  .  P  P  P  .  P 
    // 1= r  .  B  Q  K  B  Kn R  
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------

    log ("Turn 12(34): Black skips spell");
    rell.test.tx(skip_card(the_game.game_rowid, last_seen_turn)).sign(black_player).run();
    last_seen_turn += 1;
    fetching_rotation_nr += 1;

    log ("Turn 12(35): Black moves pawn e7->e6, to avoid being taken.");
    val e7 = 52; 
    val e6 = 44; 

    m_args = move_arguments(
        from_position = e7, // <-- Ok
        to_position = e6, // <-- Ok
        piece_type_str = "PAWN",  // <-- Ok
        given_is_knighted = false, 
        given_is_enchanted_jumper = false);

    rell.test.tx(move_peaceful(the_game.game_rowid, last_seen_turn, m_type, m_args, null, null, check_args_nothing)).sign(black_player).run();
    last_seen_turn += 1;
    
    log ("Turn 12(36): Skip neutral.");
    last_seen_turn += 1;

    // +++++++++++++++++++++++++++++++++++++++++ White Move 13 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 8= .  kn b  q  k  b  kn r
    // 7= .  p  p  p  -  p  .  p // <--- prev: Pawn e7 -> e5
    // 6= .  .  .  .  p  P  p  .
    // 5= .  .  .  .  .  .  .  . // <--- prev: Pawn e7 -> e5
    // 4= Kn .  .  .  .  .  .  . 
    // 3= .  Pk .  .  .  .  P  . 
    // 2= .  .  +  P  P  P  .  P // <-- next: Queen d1 -> c2 
    // 1= r  .  B  Q  K  B  Kn R // <-- next: Queen d1 -> c2 
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------

    log("Turn 13(37): White skips spell.");
    rell.test.tx(skip_card(the_game.game_rowid, last_seen_turn)).sign(white_player).run();
    last_seen_turn += 1;
    fetching_rotation_nr += 1;

    log("Turn 13(38): White makes a valid move Queen d1 -> c2. Trying to trap the rook.");
    val d1 = 3;

    m_args = move_arguments(
        from_position = d1, // <-- Ok
        to_position = c2, // <-- Ok
        piece_type_str = "QUEEN",  // <-- Ok
        given_is_knighted = false, 
        given_is_enchanted_jumper = false);

    rell.test.tx(move_peaceful(the_game.game_rowid, last_seen_turn, m_type, m_args, null, null, check_args_nothing)).sign(white_player).run();
    last_seen_turn += 1;

    log ("Turn 13(39): Skip neutral.");
    last_seen_turn += 1;

    // +++++++++++++++++++++++++++++++++++++++++ Black Move 14 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 8= @  kn b  q  k  b  kn r // <-- next: Queen d8 x f6 (will cause resurrection)
    // 7= .  p  p  p  .  p  .  p
    // 6= .  .  .  .  p  P  p  . // <-- next: Queen d8 x f6 (will cause resurrection)
    // 5= .  .  .  .  .  .  .  .
    // 4= Kn .  .  .  .  .  .  . 
    // 3= .  Pk .  .  .  .  P  . 
    // 2= .  .  Q  P  P  P  .  P // <-- prev: Queen d1 -> c2
    // 1= r  .  B  -  K  B  Kn R // <-- prev: Queen d1 -> c2   
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------

    log ("Turn 14(40): Black skips spell");
    rell.test.tx(skip_card(the_game.game_rowid, last_seen_turn)).sign(black_player).run();
    last_seen_turn += 1;
    fetching_rotation_nr += 1;

    log ("Turn 14(41): Black captures pawn d8->f6, causing resurrection.");
    val d8 = 59;

    m_args = move_arguments(
        from_position = d8, 
        to_position = f6, 
        piece_type_str = "QUEEN",  
        given_is_knighted = false, 
        given_is_enchanted_jumper = false);

    // Attack data, mandatory for attacks.
    att_args = move_attack_arguments (
        attacked_position = f6, 
        attack_result_type_str = "KILL", 
        defender_defense_points = 3, 
        damage_points = 7 
    );

    end_args = move_end_events_arguments(
        used_portals = list<integer>(),
        resurrection_pos = a8, // First free position at first rank
        promotions = list<integer>()
    );

    var resurrect_rnd_data = rnd_data(
        result = 0, // We put the resurrected at a8, which is one out of two squares
        min = 0, // 
        max = 1 // The two options are a8 and d8 (where the queen started, but no longer holds).
    );
    rnds = [resurrect_rnd_data];

    rell.test.tx(move_attack(the_game.game_rowid, last_seen_turn, m_type, m_args, att_args, rnds, check_args_nothing, end_args)).sign(black_player).run();
    last_seen_turn += 1;

    log ("Turn 14(42): Skip neutral.");
    last_seen_turn += 1;

    // +++++++++++++++++++++++++++++++++++++++++ White Move 15 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 8= p  kn b  -  k  b  kn r // <-- prev: pawn resurrected at a8.
    // 7= .  p  p  p  .  p  .  p
    // 6= .  .  .  .  p  q  p  . // <-- prev: Captured by Queen d8 x f6 (will cause resurrection)
    // 5= .  .  .  .  .  .  .  .
    // 4= Kn .  .  .  .  .  .  . 
    // 3= .  Pk .  .  .  .  P  . // <-- next: Instead KNIGHTED pawn goes b3 x a1, causing the rook to resurrect.
    // 2= .  .  Q  P  P  P  .  P // <-- next: We want to verify that White cannot move Bishop c1 -> d2 (causing check).
    // 1= r  @  B  .  K  B  Kn R // <-- next: 1) KNIGHTED pawn takes b3 x a1. 2) Resurrect at b1.
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------

    log("Turn 15(43): White skips spell.");
    rell.test.tx(skip_card(the_game.game_rowid, last_seen_turn)).sign(white_player).run();
    last_seen_turn += 1;
    fetching_rotation_nr += 1;

    // --------------------
    // Failed White moves
    // --------------------
    log("Turn 15(44): Move Fail . Bishop cannot move c1 -> b2 to put king in check!");
    val c1 = 2; // c1 (correct)

    m_args = move_arguments(
        from_position = c1, // <-- Ok
        to_position = b2, // <-- Valid bishop move, but will cause check
        piece_type_str = "BISHOP",  
        given_is_knighted = false, 
        given_is_enchanted_jumper = false);

    failed_move = assert_fails(move_peaceful_inner(white_player.pub, the_game.game_rowid, last_seen_turn, m_type, m_args, null, null, check_args_nothing,
        * // Note, this star is what makes it work.
    ));
    val expected_move_causes_check: text = "Move puts us into check: type: BISHOP";
    log(failed_move.message);
    assert_true(failed_move.message.starts_with(expected_move_causes_check));

    // --------------------
    // /Failed White moves
    // --------------------

    log("Turn 15(44): White makes a valid move KNIGHTED pawn b3 x a1, capturing the rook, causing resurrection.");

     m_args = move_arguments(
        from_position = b3, 
        to_position = a1, 
        piece_type_str = "PAWN",  
        given_is_knighted = true, 
        given_is_enchanted_jumper = false);


    // Attack data, mandatory for attacks.
    att_args = move_attack_arguments (
        attacked_position = a1, 
        attack_result_type_str = "KILL", 
        defender_defense_points = 3, 
        damage_points = 7 
    );

    val b1 = 1;
    end_args = move_end_events_arguments(
        used_portals = list<integer>(),
        resurrection_pos = b1, // First free position at first rank
        promotions = list<integer>()
    );

    resurrect_rnd_data = rnd_data(
        result = 0, // We put the resurrected at b1, which is the first available square.
        min = 0, 
        max = 1 // Only two squares on rank 1 (b1, d1)
    );
    rnds = [resurrect_rnd_data];

    rell.test.tx(move_attack(the_game.game_rowid, last_seen_turn, m_type, m_args, att_args, rnds, check_args_nothing, end_args)).sign(white_player).run();
    last_seen_turn += 1;

    log ("Turn 15(45): Skip neutral.");
    last_seen_turn += 1;


    // +++++++++++++++++++++++++++++++++++++++++ Black Move 16 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 8= p  kn b  .  k  b  kn r
    // 7= .  p  p  p  .  p  .  p
    // 6= .  .  .  .  p  q  p  . // <-- next: queen f6 -> c3
    // 5= .  .  .  .  .  .  .  .
    // 4= Kn .  .  .  .  .  .  . 
    // 3= .  -  +  .  .  .  P  . // <-- prev: KNIGHTED pawn takes rook via b3 x a1. // <-- next: queen f6 -> c3
    // 2= .  .  Q  P  P  P  .  P 
    // 1= Pk R  B  .  K  B  Kn R // <-- prev: KNIGHTED pawn goes b3 x a1, causing the rook to resurrect at b1.
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------

    log ("Turn 16(46): Black skips spell");
    rell.test.tx(skip_card(the_game.game_rowid, last_seen_turn)).sign(black_player).run();
    last_seen_turn += 1;
    fetching_rotation_nr += 1;

    log ("Turn 16(47): Black moves queen f6 -> c3 (pretty stupid move).");

    m_args = move_arguments(
        from_position = f6, // <-- Ok
        to_position = c3, // <-- Ok
        piece_type_str = "QUEEN",  // <-- Ok
        given_is_knighted = false, 
        given_is_enchanted_jumper = false);

    rell.test.tx(move_peaceful(the_game.game_rowid, last_seen_turn, m_type, m_args, null, null, check_args_nothing)).sign(black_player).run();
    last_seen_turn += 1;
    
    log ("Turn 16(48): Skip neutral.");
    last_seen_turn += 1;

    // +++++++++++++++++++++++++++++++++++++++++ White Move 17 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 8= p  kn b  .  k  b  kn r
    // 7= .  p  p  p  .  p  .  p // <-- next: JUMP on queen c2 -> c7
    // 6= .  .  .  .  p  -  p  . // <-- prev: queen f6 -> c3
    // 5= .  .  .  .  .  .  .  .
    // 4= Kn .  .  .  .  .  .  . 
    // 3= .  .  q  .  .  .  P  . // <-- prev: queen f6 -> c3
    // 2= .  .  Q  P  P  P  .  P // <-- next: fails to put a PORTAL on d2 (causes check), instead JUMP on queen c2 -> c7
    // 1= Pk R  B  .  K  B  Kn R 
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------

    // Bit tricky to figure out what the random number should be to put the exit b6
    val d2 = 11;
    val b6 = 41;
    total_empty_squares_on_black_side = 18; 
    max_portal_empty_squares = total_empty_squares_on_black_side - 1;
    portal_rnd_result = 10; // b6. Start counting from rank 5. 0->7 (=8 steps). Rank 4. 8-> 9 (2 steps)
    portal_rnd_data = rnd_data(
        result = portal_rnd_result, 
        min = min_portal_empty_squares, 
        max = max_portal_empty_squares
    );
    rnds= [portal_rnd_data];

    log("Turn 17(49): Card Fail, PORTAL on d2 (causes check).");
    minimal_game = minimal_game_data_get(white_player.pub);
    require(minimal_game != null, "Player is not in a game");
    reverted_list = card_enchantment_revert_timed_out(minimal_game.game, minimal_game.player_game);

    crd_data = card_played_data(
        card_type_str = "PORTAL",
        card_order_number = 1,
        card_picks = [d2, b6],
    );
    failed_card = assert_fails(card_play_inner_core(minimal_game, the_game.game_rowid, last_seen_turn, crd_data, rnds, reverted_list,
        * // Note, this star is what makes it work.
    ));
    //log(failed_card.message);
    val expected_portal_check_msg: text = "Cannot use PORTAL on a piece, so that when it moves to the exit it causes a check";
    assert_true(failed_card.message.starts_with(expected_portal_check_msg));

    log("Turn 17(49): White plays JUMP (on Queen on C2).");

    crd_data = card_played_data(
        card_type_str = "JUMP",
        card_order_number = 4,
        card_picks = [c2],
    );
    rell.test.tx(play_card(the_game.game_rowid, last_seen_turn, crd_data, list<rnd_data>())).sign(white_player).run();
    last_seen_turn += 1;
    fetching_rotation_nr += 1;

    // --------------------
    // Failed White moves
    // --------------------
    log("Turn 17(50): Move Fail. Bishop cannot move f1 -> d3 (Only the enchanted piece can jump)");
    val f1 = 5; 
    val d3 = 19;

    m_args = move_arguments(
        from_position = f1, // <-- Ok
        to_position = d3, // <-- Only valid bishop move if we can jump
        piece_type_str = "BISHOP",  
        given_is_knighted = false, 
        given_is_enchanted_jumper = false); // <-- We don't claim to be an enchanted jumper

    failed_move = assert_fails(move_peaceful_inner(white_player.pub, the_game.game_rowid, last_seen_turn, m_type, m_args, null, null, check_args_nothing,
        * // Note, this star is what makes it work.
    ));
    var move_expected_err_msg: text = "Illegal move: type: BISHOP";
    //log(failed_move.message);
    assert_true(failed_move.message.starts_with(move_expected_err_msg));

    log("Turn 17(50): Move Fail. Bishop cannot move f1 -> d3 (Only the enchanted piece can jump)");

    m_args = move_arguments(
        from_position = f1, // <-- Ok
        to_position = d3, // <-- Only valid bishop move if we can jump
        piece_type_str = "BISHOP",  
        given_is_knighted = false, 
        given_is_enchanted_jumper = true); // <-- NOT TRUE! It's the Queen that got the enchantment.

    failed_move = assert_fails(move_peaceful_inner(white_player.pub, the_game.game_rowid, last_seen_turn, m_type, m_args, null, null, check_args_nothing,
        * // Note, this star is what makes it work.
    ));
    move_expected_err_msg = "This piece is not an enchanted jumper";
    //log(failed_move.message);
    assert_true(failed_move.message.starts_with(move_expected_err_msg));

    // --------------------
    // /Failed White moves
    // --------------------

    log("Turn 17(50): White makes a successful jump with the Queen c2 -> c7");
    val c7 = 50;

     m_args = move_arguments(
        from_position = c2, 
        to_position = c7, 
        piece_type_str = "QUEEN",  
        given_is_knighted = false, 
        given_is_enchanted_jumper = true); // <-- MUST SET FLAG! 

    // Attack data, mandatory for attacks.
    att_args = move_attack_arguments (
        attacked_position = c7, 
        attack_result_type_str = "KILL", 
        defender_defense_points = 3, 
        damage_points = 7 
    );

    rell.test.tx(move_attack(the_game.game_rowid, last_seen_turn, m_type, m_args, att_args, list<rnd_data>(), check_args_nothing)).sign(white_player).run();
    last_seen_turn += 1;

    log ("Turn 17(51): Skip neutral.");
    last_seen_turn += 1;

    assert_equals(last_seen_turn, 51);
    assert_equals(fetching_rotation_nr, 17);

    // +++++++++++++++++++++++++++++++++++++++++ Black Move 18 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 8= p  kn b  .  k  b  kn r
    // 7= .  p  Q  p  .  p  .  p // <-- prev: JUMP on queen c2 -> c7
    // 6= .  .  .  .  p  .  p  . 
    // 5= .  .  .  .  .  .  .  .
    // 4= Kn .  .  .  .  .  .  . 
    // 3= .  .  q  .  .  .  P  . 
    // 2= .  .  -  P  P  P  .  P // <-- prev: JUMP on queen c2 -> c7
    // 1= Pk R  B  .  K  B  Kn R 
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------

    log("Turn 18(52): Black plays DOUBLE_MOVE");
    crd_data = card_played_data(
        card_type_str = "DOUBLE_MOVE",
        card_order_number = 3,
        card_picks = [],
    );
    rell.test.tx(play_card(the_game.game_rowid, last_seen_turn, crd_data, list<rnd_data>())).sign(black_player).run();
    last_seen_turn += 1;
    fetching_rotation_nr += 1;

    log ("Turn 18(53): Black must skip move (due to double move).");
    end_args = move_end_events_arguments(
        used_portals = [],
        resurrection_pos = null, 
        promotions = list<integer>()
    );

    rell.test.tx(skip_primary_move(the_game.game_rowid, last_seen_turn, m_type, check_args_nothing, end_args)).sign(black_player).run();
    last_seen_turn += 1;

    log ("Turn 18(54): Skip neutral.");
    last_seen_turn += 1;

    // +++++++++++++++++++++++++++++++++++++++++ White Move 19 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 8= p  kn b  .  k  b  kn r // <-- next: Queen c7 -> c8 (check)
    // 7= .  p  Q  p  .  p  .  p // <-- next: Queen c7 -> c8 (check)
    // 6= .  .  .  .  p  .  p  .
    // 5= .  .  .  .  .  .  .  .
    // 4= Kn .  .  .  .  .  .  . 
    // 3= .  .  q  .  .  .  P  . 
    // 2= .  .  .  P  P  P  .  P 
    // 1= Pk R  B  .  K  B  Kn R 
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------

    // Whit is acting pretty stupid here, should have taken the black queen on c3, but this way we will get an interesting  end to the game.

    log("Turn 19(55): Skip card.");
    rell.test.tx(skip_card(the_game.game_rowid, last_seen_turn)).sign(white_player).run();
    last_seen_turn += 1;
    fetching_rotation_nr += 1;

    log ("Turn 19(56): White captuers bishop c7->c8, causing check.");
    val c8 = 58;

    m_args = move_arguments(
        from_position = c7, 
        to_position = c8, 
        piece_type_str = "QUEEN",  
        given_is_knighted = false, 
        given_is_enchanted_jumper = false);


    // Attack data, mandatory for attacks.
    att_args = move_attack_arguments (
        attacked_position = c8, 
        attack_result_type_str = "KILL", 
        defender_defense_points = 3, 
        damage_points = 7 
    );

    
    var check_args = move_check_arguments(
        is_check = true,
        is_checkmate = false,
        is_stalemate = false,
        is_insufficient_mating_material = false,   
        random_seed = null,
        seed_signature = null
    );

    rell.test.tx(move_attack(the_game.game_rowid, last_seen_turn, m_type, m_args, att_args, list<rnd_data>(), check_args)).sign(white_player).run();
    last_seen_turn += 1;
    
    log ("Turn 19(57): Skip neutral.");
    last_seen_turn += 1;

    // +++++++++++++++++++++++++++++++++++++++++ Black Move 20 (TWO MOVES!!) ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 8= p  kn Q  .  k  b  kn r // <-- prev: Queen c7 -> c8 (check) // <-- next: Queen c3 -> c8 (removing check)
    // 7= .  p  -  p  .  p  .  p // <-- prev: Queen c7 -> c8 (check) 
    // 6= .  .  .  .  p  .  p  .
    // 5= .  .  .  .  .  .  .  .
    // 4= Kn .  .  .  .  .  .  . 
    // 3= .  .  q  .  .  .  P  . // <-- next: Queen c3 -> c8 (removing check)
    // 2= .  .  .  P  P  P  .  P 
    // 1= Pk R  B  .  K  B  Kn R 
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------

    // --------------------------
    // 8= p  kn q  .  k  b  kn r // <-- prev: Queen c3 -> c8 (removing check) // <-- next: Queen c8 -> c2 
    // 7= .  p  .  p  .  p  .  p  
    // 6= .  .  .  .  p  .  p  .
    // 5= .  .  .  .  .  .  .  .
    // 4= Kn .  .  .  .  .  .  . 
    // 3= .  .  -  .  .  .  P  . // <-- prev: Queen c3 -> c8 (removing check)
    // 2= .  .  +  P  P  P  .  P // <-- next: Queen c8 -> c2 
    // 1= Pk R  B  .  K  B  Kn R 
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------

    log ("Turn 20(58): Black skips spell");
    rell.test.tx(skip_card(the_game.game_rowid, last_seen_turn)).sign(black_player).run();
    last_seen_turn += 1;
    fetching_rotation_nr += 1;

    log ("Turn 20(59): Black captures queen c3->c8, removing check.");

    m_args = move_arguments(
        from_position = c3, 
        to_position = c8, 
        piece_type_str = "QUEEN",  
        given_is_knighted = false, 
        given_is_enchanted_jumper = false);

    // Attack data, mandatory for attacks.
    att_args = move_attack_arguments (
        attacked_position = c8, 
        attack_result_type_str = "KILL", 
        defender_defense_points = 3, 
        damage_points = 7 
    );

    val THIS_IS_THE_FIRST_DOUBLE_MOVE = move_type.DOUBLE_MOVE_FIRST.name;
    rell.test.tx(move_attack(the_game.game_rowid, last_seen_turn, THIS_IS_THE_FIRST_DOUBLE_MOVE, m_args, att_args, list<rnd_data>(), check_args_nothing)).sign(black_player).run();
    last_seen_turn += 1;


    log ("Turn 20(60): Black moves queen c8 -> c2 (pretty stupid move).");
    m_args = move_arguments(
        from_position = c8, // <-- Ok
        to_position = c2, // <-- Ok
        piece_type_str = "QUEEN",  // <-- Ok
        given_is_knighted = false, 
        given_is_enchanted_jumper = false);

    val ACTUALLY_DOUBLE_MOVE = move_type.DOUBLE_MOVE_LAST.name;
    rell.test.tx(move_peaceful(the_game.game_rowid, last_seen_turn, ACTUALLY_DOUBLE_MOVE, m_args, null, null, check_args_nothing)).sign(black_player).run();
    last_seen_turn += 1;


    // +++++++++++++++++++++++++++++++++++++++++ White Move 21 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 8= p  kn -  .  k  b  kn r // <-- prev: Queen c3 -> c8 (removing check)
    // 7= .  p  .  p  .  p  .  p 
    // 6= .  .  .  .  p  .  p  . // <-- next: Knight a4 -> b6 (blunder)
    // 5= .  .  .  .  .  .  .  .
    // 4= Kn .  .  .  .  .  .  . // <-- next: Knight a4 -> b6 (blunder)
    // 3= .  .  .  .  .  .  P  . // <-- prev: Queen c3 -> c8 (removing check)
    // 2= .  .  q  P  P  P  .  P 
    // 1= Pk R  B  .  K  B  Kn R 
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------

    log("Turn 21(61): White skips spell.");
    rell.test.tx(skip_card(the_game.game_rowid, last_seen_turn)).sign(white_player).run();
    last_seen_turn += 1;
    fetching_rotation_nr += 1;

    log("Turn 21(62): White (makes a blunnder and doesn't take the Queen) moves Knight to a4 -> b6.");

    m_args = move_arguments(
        from_position = a4, // <-- Ok
        to_position = b6, // <-- Ok
        piece_type_str = "KNIGHT",  // <-- Ok
        given_is_knighted = false, 
        given_is_enchanted_jumper = false);

    rell.test.tx(move_peaceful(the_game.game_rowid, last_seen_turn, m_type, m_args, null, null, check_args_nothing)).sign(white_player).run();
    last_seen_turn += 1;

    log ("Turn 21(63): Skip neutral.");
    last_seen_turn += 1;


    // +++++++++++++++++++++++++++++++++++++++++ Black Move 22 = CHECK ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 8= p  kn -  .  k  b  kn r // <-- next: Pawn a8 -> a7 (just a random move to kick mate)
    // 7= +  p  .  p  .  p  .  p // <-- next: Pawn a8 -> a7 (just a random move to kick mate)
    // 6= .  Kn .  .  p  .  p  . // <-- prev: Knight a4 -> b6 (blunder)
    // 5= .  .  .  .  .  .  .  .
    // 4= -  .  .  .  .  .  .  . // <-- prev: Knight a4 -> b6 (blunder)
    // 3= .  .  .  .  .  .  P  . 
    // 2= .  .  q  P  P  P  .  P // <-- next: Queen at c2 becomes KNIGHTED! Check, but not mate since KNIGHTED pawn at a1 can take.
    // 1= Pk R  B  .  K  B  Kn R 
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------
    log("Turn 22(64): Black plays KNIGHTED card (on c2 Queen).");
    card_picks_knighted = [c2]; // Turns c3 pawn into knight
    crd_data = card_played_data(
        card_type_str = "KNIGHTED",
        card_order_number = 4,
        card_picks = card_picks_knighted,
    );

    rell.test.tx(play_card(the_game.game_rowid, last_seen_turn, crd_data, list<rnd_data>())).sign(black_player).run();
    last_seen_turn += 1;
    fetching_rotation_nr += 1;

    // Black's card already put the opponent in Check (via the KNIGHTED Queen).
    // For performance reasons we don't do the checkmate control until after the move, 
    // so even if black (incorrectly) thought this was mate they would have to make a dummy move here potentially win. 
    // (This is not a bug, but by design, a player only ever wins during primary move (skipped or not) OR 
    // during the hijacked neutral move (second double move)).

    log ("Turn 22(65): Black moves resurrected pawn a8 -> a7.");

    val a7 = 48;
    m_args = move_arguments(
        from_position = a8, // <-- Ok
        to_position = a7, // <-- Ok
        piece_type_str = "PAWN",  // <-- Ok
        given_is_knighted = false, 
        given_is_enchanted_jumper = false);

    // NOTE! You can change "is_checkmate = true" too see what happens.
    // We cannot test this automatically since the test will break if we update the DB before the require() fails.
    check_args = move_check_arguments(
        is_check = true, // Queen at c2 becomes KNIGHTED! 
        is_checkmate = false, // <-- Not mate since KNIGHTED pawn at a1 can take.
        is_stalemate = false,
        is_insufficient_mating_material = false,
        random_seed = null,
        seed_signature = null
    );

    rell.test.tx(move_peaceful(the_game.game_rowid, last_seen_turn, m_type, m_args, null, null, check_args)).sign(black_player).run();
    last_seen_turn += 1;
    

    // This should probably fail since the game is over
    log ("Turn 22(66): Skip neutral.");
    last_seen_turn += 1;

    // +++++++++++++++++++++++++++++++++++++++++ White Move 23 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 8= -  kn .  .  k  b  kn r // <-- prev: Pawn a8 -> a7 (just a random move to kick mate)
    // 7= p  p  .  p  .  p  .  p // <-- prev: Pawn a8 -> a7 (just a random move to kick mate)
    // 6= .  Kn .  .  p  .  p  . 
    // 5= .  .  .  .  .  .  .  .
    // 4= .  .  .  .  .  .  .  . 
    // 3= .  .  .  .  .  .  P  . 
    // 2= .  .  qk P  P  P  .  P // <-- prev: Queen at c2 becomes KNIGHTED! // <-- next: KNIGHTED pawn takes a1 x c2.
    // 1= Pk R  B  .  K  B  Kn R // <-- next: KNIGHTED pawn takes a1 x c2.
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------

    log("Turn 23(67): Skip card.");
    rell.test.tx(skip_card(the_game.game_rowid, last_seen_turn)).sign(white_player).run();
    last_seen_turn += 1;
    fetching_rotation_nr += 1;

    log ("Turn 23(68): White captuers bishop c7->c8, causing check.");

    m_args = move_arguments(
        from_position = a1, 
        to_position = c2, 
        piece_type_str = "PAWN",  
        given_is_knighted = true, 
        given_is_enchanted_jumper = false);

    // Attack data, mandatory for attacks.
    att_args = move_attack_arguments (
        attacked_position = c2, 
        attack_result_type_str = "KILL", 
        defender_defense_points = 3, 
        damage_points = 7 
    );

    rell.test.tx(move_attack(the_game.game_rowid, last_seen_turn, m_type, m_args, att_args, list<rnd_data>(), check_args_nothing)).sign(white_player).run();
    last_seen_turn += 1;
    
    log ("Turn 23(69): Skip neutral.");
    last_seen_turn += 1;


    // +++++++++++++++++++++++++++++++++++++++++ Black Move 24 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 8= .  kn .  .  k  b  kn r // <-- next: knight goes g8 -> e7.
    // 7= p  p  .  p  +  p  .  p // <-- next: knight goes g8 -> e7.
    // 6= .  Kn .  .  p  .  p  . 
    // 5= .  .  .  .  .  .  .  .
    // 4= .  .  .  .  .  .  .  . 
    // 3= .  .  .  .  .  .  P  . 
    // 2= .  .  Pk P  P  P  .  P // <-- prev: KNIGHTED pawn takes a1 x c2.
    // 1= -  R  B  .  K  B  Kn R // <-- prev: KNIGHTED pawn takes a1 x c2.
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------
    log ("Turn 24(70): Black skips spell");
    rell.test.tx(skip_card(the_game.game_rowid, last_seen_turn)).sign(black_player).run();
    last_seen_turn += 1;
    fetching_rotation_nr += 1;

    log ("Turn 24(71): Black moves queen f6 -> c3 (pretty stupid move).");

    val g8 = 62;
    m_args = move_arguments(
        from_position = g8, // <-- Ok
        to_position = e7, // <-- Ok
        piece_type_str = "KNIGHT",  // <-- Ok
        given_is_knighted = false, 
        given_is_enchanted_jumper = false);

    rell.test.tx(move_peaceful(the_game.game_rowid, last_seen_turn, m_type, m_args, null, null, check_args_nothing)).sign(black_player).run();
    last_seen_turn += 1;
    
    log ("Turn 24(72): Skip neutral.");
    last_seen_turn += 1;


    // +++++++++++++++++++++++++++++++++++++++++ White Move 25 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 8= .  kn .  .  k  b  -  r // <-- prev: knight goes g8 -> e7.
    // 7= p  p  .  p  kn p  .  p // <-- prev: knight goes g8 -> e7.
    // 6= .  Kn .  .  p  .  p  . // <-- next: knight goes b6 -> c4.
    // 5= .  .  .  .  .  .  .  .
    // 4= .  .  +  .  .  .  .  . // <-- next: knight goes b6 -> c4.
    // 3= .  .  .  .  .  .  P  . 
    // 2= .  .  Pk P  P  P  .  P 
    // 1= .  R  B  .  K  B  Kn R 
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------
    log("Turn 25(73): White skips spell.");
    rell.test.tx(skip_card(the_game.game_rowid, last_seen_turn)).sign(white_player).run();
    last_seen_turn += 1;
    fetching_rotation_nr += 1;

    log("Turn 25(74): White moves Knight to b6 -> c4.");

    val c4 = 26;
    m_args = move_arguments(
        from_position = b6, // <-- Ok
        to_position = c4, // <-- Ok
        piece_type_str = "KNIGHT",  // <-- Ok
        given_is_knighted = false, 
        given_is_enchanted_jumper = false);

    rell.test.tx(move_peaceful(the_game.game_rowid, last_seen_turn, m_type, m_args, null, null, check_args_nothing)).sign(white_player).run();
    last_seen_turn += 1;

    log ("Turn 25(75): Skip neutral.");
    last_seen_turn += 1;

    // +++++++++++++++++++++++++++++++++++++++++ Black Move 26 ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 8= .  kn .  .  k  b  .  r // <-- next: knight goes b8 -> c6
    // 7= p  p  .  p  kn p  .  p 
    // 6= .  -  +  .  p  .  p  . // <-- prev: knight goes b6 -> c4. // <-- next: knight goes b8 -> c6
    // 5= .  .  .  .  .  .  .  .
    // 4= .  .  Kn .  .  .  .  . // <-- prev: knight goes b6 -> c4.
    // 3= .  .  .  .  .  .  P  . 
    // 2= .  .  Pk P  P  P  .  P 
    // 1= .  R  B  .  K  B  Kn R 
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------
    log ("Turn 26(76): Black skips spell");
    rell.test.tx(skip_card(the_game.game_rowid, last_seen_turn)).sign(black_player).run();
    last_seen_turn += 1;
    fetching_rotation_nr += 1;

    log ("Turn 26(77): Black moves queen f6 -> c3 (pretty stupid move).");

    val b8 = 57;
    val c6 = 42;
    m_args = move_arguments(
        from_position = b8, // <-- Ok
        to_position = c6, // <-- Ok
        piece_type_str = "KNIGHT",  // <-- Ok
        given_is_knighted = false, 
        given_is_enchanted_jumper = false);

    rell.test.tx(move_peaceful(the_game.game_rowid, last_seen_turn, m_type, m_args, null, null, check_args_nothing)).sign(black_player).run();
    last_seen_turn += 1;
    
    log ("Turn 26(78): Skip neutral.");
    last_seen_turn += 1;


    // +++++++++++++++++++++++++++++++++++++++++ White Move 27: CHECKMATE ++++++++++++++++++++++++++++++++++++++++++++++++++
    // 8= .  W  W  W  k  b  .  r // <-- prev: knight goes b8 -> c6 // <-- Card: Wall b8-d8
    // 7= p  p  .  p  kn p  .  p 
    // 6= .  -  kn +  p  .  p  . // <-- prev: knight goes b8 -> c6 // <-- next: knight goes c4 -> d6: CHECKMATE
    // 5= .  .  .  .  .  .  .  .
    // 4= .  .  Kn .  .  .  .  . // <-- next: knight goes c4 -> d6: CHECKMATE
    // 3= .  .  .  .  .  .  P  . 
    // 2= .  .  Pk P  P  P  .  P 
    // 1= .  R  B  .  K  B  Kn R 
    // --------------------------
    //    a  b  c  d  e  f  g  h
    // --------------------------
    log("Turn 27(79): White plays WALL (to shut off the black king).");
    crd_data = card_played_data(
        card_type_str = "WALL",
        card_order_number = 2,
        card_picks = [b8, c8, d8] 
    );
    rell.test.tx(play_card(the_game.game_rowid, last_seen_turn, crd_data, list<rnd_data>())).sign(white_player).run();
    last_seen_turn += 1;
    fetching_rotation_nr += 1;

    log("Turn 27(80): White moves Knight to c4 -> d6 (CHECKMATE)");

    val d6 = 43;
    m_args = move_arguments(
        from_position = c4, // <-- Ok
        to_position = d6, // <-- Ok
        piece_type_str = "KNIGHT",  // <-- Ok
        given_is_knighted = false, 
        given_is_enchanted_jumper = false);

    check_args = move_check_arguments(
        is_check = true, 
        is_checkmate = true, // <-- CHECKMATE!
        is_stalemate = false,
        is_insufficient_mating_material = false,
        random_seed = 7, // Validation will fail since this number is just made up.
        seed_signature = byte_array.from_hex("11223344556677881122334455667788112233445566778811223344556677881122334455667788112233445566778811223344556677881122334455667788") // Validation will fail since this number is just made up.
    );

    rell.test.tx(move_peaceful(the_game.game_rowid, last_seen_turn, m_type, m_args, null, null, check_args)).sign(white_player).run();
    last_seen_turn += 1;

    log ("Turn 27(81): Skip neutral.");
    last_seen_turn += 1;

    /*
    // ------------------------------------------------
    // Before Termination
    // ------------------------------------------------
    // White = Charlie 
    // Black = Alice 
    // White made the CHECKMATE, but since Charlie provided the incorrect seed he lost.

    postchain=> SELECT rowid, name, games_played, games_won, games_lost, games_drawn, elo_rating 
    FROM "c0.player" order by rowid;

    rowid |  name   | games_played | games_won | games_lost | games_drawn | elo_rating
    -------+---------+--------------+-----------+------------+-------------+------------
        1 | Alice   |            1 |         1 |          0 |           0 |       1216
        2 | Bob     |            0 |         0 |          0 |           0 |       1200
        3 | Charlie |            1 |         0 |          1 |           0 |       1184
        4 | Dave    |            0 |         0 |          0 |           0 |       1200
    (4 rows)

    postchain=> SELECT white_player, black_player, current_turn_nr, is_finished, finish_reason, 
    valid_seeds_count, invalid_seeds_count FROM "c0.game";

    white_p  | black_p | turn_nr | is_finished | finish_r | valid_seeds | invalid_seeds
    ---------+---------+---------+-------------+----------+-------------+--------------
           3 |       1 |      80 | t           |        0 |           0 |             1
    (1 row)

    postchain=> SELECT rowid, player, is_white FROM "c0.player_game";

    rowid | player | is_white
    -------+--------+----------
        10 |      1 | f
         9 |      3 | t
    (2 rows)

    postchain=> SELECT player_game, seed, validation_success FROM "c0.player_game_seed";

    player_game | seed | validation_success
    -- ---------+------+--------------------
              9 |    7 | f
    (1 row)

    postchain=> SELECT player, finish_reason, claim_is_winner, is_winner, claim_new_elo_rating, new_elo_rating 
    FROM "c0.player_game_stats";

    player | finish_reason | claim_is_winner | is_winner | claim_new_elo_rating | new_elo_rating
    -------+---------------+-----------------+-----------+----------------------+----------------
         1 |             0 | t               | t         |                 1216 |           1216
         3 |             0 | f               | f         |                 1184 |           1184
    (2 rows)

    // ------------------------------------------------
    */


    // ------------------------------------
    // Black sends seed
    // ------------------------------------
    val black_seed = 42; // Just made up number, but since BOTH seed verifations fail we'll get a draw.
    val black_seed_signature_64_bytes = byte_array.from_hex("1F2F3F4F5F6F7F8F1F2F3F4F5F6F7F8F1F2F3F4F5F6F7F8F1F2F3F4F5F6F7F8F1F2F3F4F5F6F7F8F1F2F3F4F5F6F7F8F1F2F3F4F5F6F7F8F1F2F3F4F5F6F7F8F"); // Validation will fail since this number is just made up.
    rell.test.tx(terminate_game_with_seed(the_game.game_rowid, black_seed, black_seed_signature_64_bytes)).sign(black_player).run();

    /*
    // ------------------------------------------------
    // After Termination
    // ------------------------------------------------
    // White = Charlie 
    // Black = Alice 
    // Black provided the incorrect seed too, so we're changing the result to draw.

    postchain=> SELECT rowid, name, games_played, games_won, games_lost, games_drawn, elo_rating FROM "c0.player" order by rowid;
    rowid |  name   | games_played | games_won | games_lost | games_drawn | elo_rating
    ------+---------+--------------+-----------+------------+-------------+------------
        1 | Alice   |            1 |         0 |          0 |           1 |       1200
        2 | Bob     |            0 |         0 |          0 |           0 |       1200
        3 | Charlie |            1 |         0 |          0 |           1 |       1200
        4 | Dave    |            0 |         0 |          0 |           0 |       1200
    (4 rows)

    postchain=> SELECT white_player, black_player, current_turn_nr, is_finished, finish_reason, 
    valid_seeds_count, invalid_seeds_count FROM "c0.game";

    white_p | black_p | turn_nr | is_finished | finish_r | valid_seeds | invalid_seeds
    --------+---------+---------+-------------+----------+-------------+--------------
          3 |       1 |      80 | t           |        0 |           0 |             2
    (1 row)

    postchain=> SELECT player_game, seed, validation_success FROM "c0.player_game_seed";
    player_game | seed | validation_success
    ------------+------+--------------------
              9 |    7 | f
             10 |   42 | f
    (2 rows)

    postchain=> SELECT player, finish_reason, claim_is_winner, is_winner, claim_is_draw, is_draw, claim_new_elo_rating, new_elo_rating 
    FROM "c0.player_game_stats";

    player | finish_reason | claim_is_winner | is_winner | claim_is_draw | is_draw | claim_new_elo_rating | new_elo_rating
    -------+---------------+-----------------+-----------+---------------+---------+----------------------+----------------
         3 |             0 | f               | f         | f             | t       |                 1184 |           1200
         1 |             0 | t               | f         | f             | t       |                 1216 |           1200
    (2 rows)
    // ------------------------------------------------
    */

}

/*
// Not testing anything, just printing the numbers
// to see if any are missing
function test_random() {

    val random_numbers = generate_random_numbers(1238567, 1000, 11);

    var str = "rnd: ";
    val sorted_map = map<integer, integer>();  
    for (n in random_numbers) {
        str += n.to_text() + ", ";
        if (sorted_map.contains(n)) {
            val cnt = sorted_map[n];
            sorted_map[n] = cnt + 1;
        } else {
            sorted_map[n] = 1;
        }
    }

    log(str);

    for (i in range(12)) { // <- 0-11
        if (sorted_map.contains(i)) {
            log(i.to_text() + " = " + sorted_map[i].to_text());
        } else {
            log(i.to_text() + " = NOTHING!? ");
        }
    }
}
*/



