

// A non-attacking move
function move_peaceful_inner(
    caller_pubkey: pubkey,

    game_id: integer,
    last_seen_turn: integer,
    move_type_str: text, // If this move is part of a double move or not.

    m_args: move_arguments,

    // Treat castle as special case, since only peaceful moves can castle.
    castle_rook_from: integer?, // If this is a castle, the rook's starting position.
    castle_rook_to: integer?, // If this is a castle, the rook's ending position.

    check_args: move_check_arguments? = null,

    // Events that might happen after a move.
    end_args: move_end_events_arguments? = null
) {
    // ----------------------------------------------    
    // A. Verification
    // ----------------------------------------------    
    // No need to do any updates before we have verified everything.
    // (But Chromia will roll back any updates if we get an error, so it's not critical that we do it this way.)

    var dbg = move_debug_str(m_args, check_args);
    if (castle_rook_from != null) {
        dbg += "Castle ";
    }
    val p_dbg = "type: " + m_args.piece_type_str + " (from: " + m_args.from_position + " to: " + m_args.to_position + ")";

    log("game_id: " + game_id + " - Move Peaceful Begin: last_turn: " + last_seen_turn, ", m_type: " + move_type_str + ", piece " + p_dbg + ", flags: " + dbg );
    
    val m_type_upper = move_type_str.upper_case();
    val m_type: move_type = move_type.value(m_type_upper);

    // ----------------
    // A.1. Check player entity
    // ----------------
    //log("Move A.1");
    val minimal_game: minimal_game_result? = minimal_game_data_get(caller_pubkey);
    require(minimal_game != null, "Player is not in a game, id:" + game_id);
    require(minimal_game.game_id == game_id, "The game id of the ongoing game " + minimal_game.game_id + " doesn't match the given id " + game_id + ".");


    // ----------------
    // A.2. Is game is out of sync? 
    // ----------------
    //log("Move A.2");
    val old_turn_nr = minimal_game.curr_turn_nr; // Soon to be updated
    require(old_turn_nr == last_seen_turn, "Player client is on turn " + last_seen_turn + " but blockchain is on turn " + old_turn_nr);

    // ----------------
    // A.3. Validate positions
    // ----------------
    //log("Move A.3");
    move_verify_pos(game_id, m_args);

    // ----------------
    // A.4. Verify piece type and position
    // ----------------
    //log("Move A.4: " + m_args.piece_type_str + " at " + m_args.from_position);
    val v_res = move_verify_basic_move(game_id, m_args, minimal_game);
    val p_type = v_res.p_type; // The main piece type
    val p = v_res.p; // The main piece data
    val my_color = v_res.align; // This players color
    val opp_color = v_res.opp_align; // Opponent's color

    val is_pawn_move = p_type == piece_type.PAWN;

    // ----------------
    // A.5 Get same state
    // ----------------
    // Has this piece an jump enchantment on it?
    val is_enchanted_jump = jump_has_enchanted(minimal_game.player_game, p.p, m_args.given_is_enchanted_jumper);

    val res = move_get_vuln_path(minimal_game.game, opp_color); 
    val opp_vuln_ctxt: pre_vuln_context = res.v_ctxt;

    // ----------------
    // A.6. Verify if move is legal
    // ----------------

    val board_p: list<with_pos_and_alignment_and_type> = piece_get_all_as_wpat(minimal_game.game); 
    val board_o: list<with_pos_and_alignment_and_type> = vuln_get_obstacles_as_wpat(minimal_game.game); 
    val portals: list<portal_simple> = portal_simple_get_all(minimal_game.game);
    val board_positions_all = board_positions_all_constructor(board_p, board_o, portals, opp_vuln_ctxt);


    // Complex verification (still easier than check mate).
    var is_castle = false;
    var rook: alive? = null;
    var m_tree: move_tree? = null;
    var selected_path: path_base? = null;
    val is_chaos_mode = not game_is_classic(minimal_game.game_type);


    if (castle_rook_from != null and castle_rook_to != null) { 
        // ----------------
        // 6.a) Castling
        // ----------------
        //log("Move A.6.a");
        rook = move_castle_verify_and_return_rook(game_id, m_args.from_position, m_args.to_position, castle_rook_from, castle_rook_to, p_type, minimal_game.is_white, minimal_game.game);
        is_castle = true;

        // We use the kings path as the main path
        selected_path = move_castle_get_king_path(game_id, m_args.from_position, m_args.to_position, minimal_game.is_white);

    } else {

        // ----------------
        // 6.b) Normal move, must verify
        // ----------------

        //log ("Move A.6.b.1 - calc move trees ");
        val (ground_m_tree: move_tree?, jump_m_tree: move_tree?) = rules_get_all_valid_moves(
            game_id,
            board_positions_all, 
            p_type,
            is_enchanted_jump,
            p.is_knighted,
            m_args.from_position,
            my_color,
            opp_vuln_ctxt, // Not actually needed. (this is a peaceful move, so we don't need to check for vulnerable paths)
            is_chaos_mode
        );

        //log ("Move A.6.b.2 - move trees done ");
        require(ground_m_tree != null or jump_m_tree != null, "No move tree found, cannot move piece " + p_dbg + ", id:" + game_id);
        m_tree = move_tree_merge(ground_m_tree, jump_m_tree);
        require(m_tree != null, "Failed merge?");

        val found_move = move_tree_get_pos_status(game_id, m_tree, m_args.to_position);
        require(found_move > 0, "Illegal move: " + p_dbg + ", id:" + game_id);
        require(found_move == 1, "Reported peaceful move is attacking move: " + p_dbg + ", id:" + game_id);

        selected_path = move_tree_build_active_path_from_destination(game_id, m_tree, m_args.to_position);
    }
    require(selected_path != null, "Failed to build active path from destination: " + p_dbg + ", id:" + game_id);

    // Get all pieces of both teams
    // Expensive, so we wait until last moment
    val our_team = team_build_from_db(minimal_game.game, my_color);
    val opp_team = team_build_from_db(minimal_game.game, opp_color);

    val our_king = team_get_king(our_team)!!;
    val opp_king = team_get_king(opp_team)!!;

    // ----------------
    // A.7. Verify if this move will get us into check
    // ----------------
    //log ("Move A.7 - Verify if this move will get us into check ");
    val (get_into_check, check_desc) = will_hypothetical_move_cause_check(
            game_id,
            selected_path,
            my_color,
            our_king.vuln.position,
            opp_team,
            board_positions_all,
            is_chaos_mode
    );

    // The client should have stopped this move from happening.
    require(not get_into_check, "Move puts us into check: " + p_dbg + " because: " + check_desc + ", id:" + game_id);

    log("game_id: " + game_id + " - Move Peaceful passed verification, piece " + p_dbg + ", flags: " + dbg );

    // ----------------------------------------------    
    // B. Updates 
    // ----------------------------------------------    
    val new_turn_type = move_common_get_turn_type(m_type, minimal_game.is_white);

    // ----------------
    // Create the turn record
    // ----------------
    // B.1 Do this FIRST since lots of verification in here.
    val (new_turn, new_turn_nr, last_rot_nr, prev_turn, prev_turn_type) = turn_create(minimal_game.game, minimal_game.player_game, new_turn_type, minimal_game.is_white, is_pawn_move);

    // ----------------
    // B.1.a Compress the board and save to the card entity
    // ----------------
    if (prev_turn_type == turn_type.WHITE_CARD or prev_turn_type == turn_type.BLACK_CARD) {
        // We played a card last turn, update it with the compressed board.
        // Note: This belongs to the card's turn, but we do this here since we don't want to do the check calc during play card.
        move_common_update_card_with_compressed_board(game_id, board_positions_all, minimal_game, opp_king.vuln.position, our_team, prev_turn, is_chaos_mode);
    }

    // B.2.a) Typically when castling we move king first, but I want the rook to be debugged at the correct place
    if (is_castle) {
        log("game_id: " + game_id + " - Castling, moving rook from " + castle_rook_from + " to " + castle_rook_to);
        val a_rook = rook!!;
        update a_rook(.position = castle_rook_to!!);

        // Extra: Update these data structures
        val attack_allowed = false; // Think we should protest if the position is occupied.
        board_place_character_at(board_positions_all, castle_rook_from!!, castle_rook_to, attack_allowed);
        team_move_character_from_to(our_team, castle_rook_from, castle_rook_to);
    }

    // B.2.b) (Really simple for peaceful moves)
    move_common_change_piece_position(game_id, last_rot_nr, p.vuln.a, m_args.from_position, m_args.to_position, board_positions_all, our_team);

    // ----------------
    // B.3 Compress the board before we apply the end arguments.
    // ----------------
    val check_sb_data = check_sb_build_calculator(
        game_id,
        opp_king.vuln.position, // We're supposed to check the opponent's king
        our_team, // we are the checking team
        board_positions_all, // This isn't a hypothetical move, must use the new board positions
        is_chaos_mode
    );
    // Just a temporary check calc (not very expensive)
    val (after_move_check, after_move_check_desc) = check_sb_is_check_with_desc(check_sb_data);
    if (after_move_check) {
        log("game_id: "+game_id+" - Peaceful Move pre check found: " + after_move_check_desc);
    }
    val (board_compressed_mid_str: text, naked_compressed_mid_str: text) = board_compress_move_only(
        game_id, 
        board_positions_all, 
        m_args, 
        minimal_game.is_white, 
        after_move_check, 
        null, // Only for attacks
        null, // Only for attacks
        is_castle, 
        castle_rook_from, 
        castle_rook_to
    );

    // ----------------
    // Apply end_args
    // ----------------
    // B.4.a Use all unblocked portals
    move_common_use_all_unblocked_portals(game_id, old_turn_nr, minimal_game.game, new_turn, board_positions_all, our_team, opp_team, my_color, end_args, is_chaos_mode);

    // B.4.b Resurrection
    // (Must happen after the portal travel, so we won't end up blocking a portal exit)
    // NO RESURRECTION FOR PEACEFUL MOVES

    // B.4.c Promotions
    // (Must happen after the portal travel, if a pawn travels to an exit at the final rank)
    promote_all_pawns_at_final_rank(game_id, minimal_game.game, new_turn, board_positions_all, our_team, my_color, end_args);

    // ----------------
    // Check/stale/mate
    // ----------------
    // B.5 Verify if we just won via checkmate?
    val (is_check, is_checkmate, is_stalemate) = check_stale_n_mate(game_id, minimal_game, board_positions_all, opp_color, opp_king, our_team, opp_team, check_args, is_chaos_mode);



    var is_repetition = false; 
    var is_50_rule = false; 
    if (not is_checkmate and not is_stalemate) {
        // ----------------
        // Check for 3x repetition.
        // The third time an identical position on the comes up the game is over.
        // We check for two occurences of the compressed string.
        //
        // Discussion:
        // We could argue forever what should and shouldn't be in this compressed string, like if the occurance of a portal should 
        // make any difference or not. But I think it doesn't matter! The draw is generated since nobady is making progress, 
        // and the draw WILL come eventually, one repetition late doesn't matter. 
        //
        // Also: note that we only look in the "move" entity, not in "skipped_move", since if a move was skipped it's a signal that 
        // something "progressing" is going on, and should not be counted as a repetition move.
        // ----------------
        val comp_boards = move_base_find_duplicated_boards(game_id, minimal_game.game, naked_compressed_mid_str);
        if (comp_boards > 1) {
            // We found (at least) two copies of this setup. This will be the third time the same board comes up => Must make it a draw.
            log("game_id: " + game_id + " - 3x move repetition rule triggered.");
            is_repetition = true;
        }

        // ----------------
        // Check 50-move rule
        // This will almost never happen since 3x repetition will (usually) kick in before this can occur.
        // Note: we don't have to be exact about this calculation since the client cannot send us this ending
        // (i.e. we are not risking a difference between client and node's implementations).
        // ----------------
        if (not is_repetition and not is_pawn_move) { // A pawn move would invalidate the draw
            val max_turns = 50 * 3; // Using our lingo we're talking about 50 rotations, and a rotation is 3 turns.
            val diff = new_turn_nr - minimal_game.last_turn_when_pawn_advanced;
            is_50_rule = diff >= max_turns;
            if (is_50_rule) {
                log("game_id: " + game_id + " - 50-move rule triggered, new_turn_nr: " + new_turn_nr + ", last_turn_when_pawn_advanced: " 
                   + minimal_game.last_turn_when_pawn_advanced + ", diff: " + diff + ".");
            }
        }
    }

    // B.6 Create move event
    val m = move_event_creation(m_args, minimal_game, new_turn, p.p, is_castle, is_enchanted_jump, after_move_check, is_check, board_compressed_mid_str, naked_compressed_mid_str); 

    if (move_end_events_has_data(end_args)) { // Only do this if something happened in the end of the turn.
        val board_compressed_after_str: text = board_compress_after_move(
            game_id, 
            board_positions_all, 
            end_args, 
            minimal_game.is_white, 
            is_check // <-- Using the re-calculated is_check
        );
        move_end_create(new_turn, board_compressed_after_str);
    }

    // ----------------
    // B.7 Is it over?
    // ----------------
    val is_insufficient_mating_material = false; // A peaceful move won't the balance
    val is_game_over = game_over_move_claim(
        minimal_game, caller_pubkey, new_turn, is_checkmate, is_stalemate, is_insufficient_mating_material, is_repetition, is_50_rule, 
        check_args?.random_seed, check_args?.seed_signature, check_args?.player_rotation_descriptions);
    if (not is_game_over) {

        // Usually we don't set "time_left" during regular moves, but there is one case where we must make an exception:
        if (turn_is_last_double_move(new_turn_type)) {
            game_update_time_left(minimal_game);
        }

        // Cleanup
        move_cleanup_after_move(is_enchanted_jump, opp_vuln_ctxt, minimal_game, opp_color);

        // Add new vuln path (if exists and match the actual move)
        if (m_tree != null) {
            val maybe_pot_paths: list<path_base>? = m_tree.potential_vuln_paths;
            move_vuln_path_add_from_move(minimal_game.game, my_color, m, maybe_pot_paths, m_args.to_position);
        }

        // The "is_check" status of the opponent should be saved.
        game_update_turn_and_check_status(minimal_game, is_check);
        
        if (m_type == move_type.NORMAL) {
            // We only add a skipped neutral (filler) move if we don't do double move.
            val neutral_last_seen_turn = last_seen_turn + 1;
            move_neutral_skip_inner(caller_pubkey, game_id, neutral_last_seen_turn);
        }
    }

    log("game_id: " + game_id + " - /Move Peaceful End, new turn type: " + new_turn_type + ", piece " + p_dbg + ", flags: " + dbg + 
        ", is_game_over: " + is_game_over + ", opp in check: " + is_check );
}

