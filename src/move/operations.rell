
// Skip the move
// Can only happen in combination with certain spells.
operation skip_move(
    game_id: integer,
    last_seen_turn: integer // What turn the client last saw.
) {
    val current_signers = op_context.get_signers();
    val caller_pubkey = current_signers[0];

    // We do it this way so we can test failure cases.
    move_skip_inner(
        caller_pubkey,
        game_id,
        last_seen_turn
    );
}


// Skip the neutral move
// We usually skip neutral in v1.0, but we need it for double move.
operation skip_neutral(
    game_id: integer,
    last_seen_turn: integer // What turn the client last saw.
) {
    val current_signers = op_context.get_signers();
    val caller_pubkey = current_signers[0];

    // We do it this way so we can test failure cases.
    move_neutral_skip_inner(
        caller_pubkey,
        game_id,
        last_seen_turn
    );
}

// Move a piece to a empty square.
operation move_peaceful(
    m_args: move_arguments,

    // Treat castle as special case
    castle_rook_from: integer?, // If this is a castle, the rook's starting position.
    castle_rook_to: integer?, // If this is a castle, the rook's ending position.

    // ----------------------
    // Only if the client wants
    // ----------------------
    check_args: move_check_arguments? = null
) {

    // -----------    
    // Get the caller from the signature.
    // -----------    
    val current_signers = op_context.get_signers();
    val caller_pubkey = current_signers[0];

    // We do it this way so we can test failure cases.
    move_peaceful_inner(
        caller_pubkey, 
        m_args,
        castle_rook_from,
        castle_rook_to,
        check_args
    );
}

operation move_attack(
    m_args: move_arguments,

    // Mandatory arguments
    att_args: move_attack_arguments,

    // ----------------------
    // Random 
    // If any randomness was used while attacking, the numbers generated goes in here.
    // The list can have different length:
    // 1. classical mode = 0
    // 2. chaos mode normal attack: 2 die rolls or sometimes 3 die rolls if miss, 
    // 3. chaos mode retaliation: 4 die rolls.
    // ----------------------
    rnd_numbers: list<rnd_data>,  

    // ----------------------
    // Only if the client wants
    // ----------------------
    check_args: move_check_arguments? = null,

    // ----------------------
    // Needed for chaos mode
    // ----------------------

    // Chaos mode arguments
    chaos_args: move_chaos_mode_arguments? = null,

    // Only used if there is retaliation.
    ret_args: move_retaliation_arguments? = null
) {
    // -----------    
    // Get the caller from the signature.
    // -----------    
    val current_signers = op_context.get_signers();
    val caller_pubkey = current_signers[0];

    // We do it this way so we can test failure cases.
    move_attack_inner(
        caller_pubkey, 
        m_args,
        att_args,
        rnd_numbers,
        check_args,
        chaos_args,
        ret_args
    );

}

