// -------------------------------------
// Timeout
// -------------------------------------
// Rules: 
// 1. If the total time (5/10 minutes) has passed, the game CAN be timed out.
// 2. If a player hasn't made a move within a minute, AND has failed to send the
//    "I'm still here" message, the game CAN be timed out.
//   
// Motivation: A major problem is that the node doesn't have any good 
// way to know if the clients are alive or not. 
// 
// Example E:
// Assume that player A is matched with player B in the lobby. 
// Player B doesn't like his cards and simply shuts down the client.
// Player A is stuck waiting for B's first move, but nothing happens and 
// A is too irritated to even wait for the 1 min timout win, so A 
// restarts the client to find a new game in the lobby. 
// 
// Two things can happen here:
// E.1. B ha been inactive more than 60 seconds when A enters the lobby.
//      Player A will cause existing game to be terminated as a win. 
// E.2. B ha been inactive less than 60 seconds when A enters the lobby.
//      Player A CANNOT start a new game since there is no way to finish the old one.
//      In this case A has to wait so that 60 seconds have passed 
//      before entering the lobby.
// -------------------------------------



// -------------------------------------
// Update
// -------------------------------------

// Sets the [last_heartbeat] timestamp to the current block time.
// Prevents the opponent from calling TIMEOUT INACTIVE on this player.
function game_timeout_set_player_alive(gpg: player_game) {
    gpg.last_heartbeat = op_context.last_block_time; // Usually happens twice every second, so good enough.
}


// Builds a [timeout_data] struct.
function game_timeout_build_timeout_data(
    opp_abandon: boolean, // "true" if the opponent has abandoned the game
    opp_timeout: boolean, // "true" if the opponent has timed out
    otd: opponent_timeout_data, 
    my_time_left_ms: integer, 
    curr_time_ms: timestamp, 
    game_started_at: timestamp
): timeout_data {

    return timeout_data(
        opp_abandon = opp_abandon,
        opp_timeout = opp_timeout,
        is_my_turn = otd.is_my_turn,
        opp_last_heartbeat = otd.opp_last_heartbeat,
        my_time_left_ms = my_time_left_ms,
        opp_time_left_ms = otd.opp_tot_time_left_since_player_rotation_ms,
        curr_time_ms = curr_time_ms,
        last_player_rotation_at = otd.last_player_rotation_at,
        game_started_at = game_started_at
    );
}




// -------------------------------------
// game_timeout_any_player_if_possible
//
// Will terminate any old game the player might be in, no matter who
// will be the winner (i.e. who timed out).
// 
// Returns "true" if there was no old game, or if the old game was terminated.
// Returns "false" if we have an ongoing game that cannot be terminated.
//     (This means that the player is blocked from creating a new game).
//
// Q1: Why cannot the player just keep playng the unfinished game?
// A1: Because the client is still too stupid to fast forward to the moment the game was abandoned 
//     (i.e. cannot put everything on the correct place), and this way start where the old
//     game left off. Therefore we need to terminate ANY old game we find.
//     In v2.0 this might change.
// 
// Q2: But who should win? 
// A2: The player (A) who made the last move should win, but only if the opponent (B) hasn't taken action or 
//     sent "I'm alive" message for 60 seconds, turning him/her into "inactive". 
//     We want to detect bad players who escape the game (shut down the computer or something). 
//     The correct way to escap is via the "Resign" button, but we must assume some players won't show sportmanship.
//
// Q2.1: But if nobody made a move?
// A2.1: Then black is the winner and white is the loser (sicne white should have moved).
// 
// Q3: Some Chess games allow quitting during the first move without ELO penalty (i.e. was made there was NO game).
//     Why can't we allow closing of the game early on without ELO penalty?
// A3: In GoblinChess would means that if either player doesn't like his/her cards they can just leave and 
//     won't lose rating. This could lead to a majority of games being aborted early on, so we don't allow it.
// -------------------------------------

function game_timeout_any_player_if_possible(maximal_game: maximal_game_result, game_time: game_time_result, opp_timeout_data: opponent_timeout_data): boolean {

    var am_i_winner = game_timeout_did_i_make_the_last_move(
            game_time.curr_turn_nr, 
            maximal_game.is_white,
            maximal_game.my_p, 
            maximal_game.my_pg, 
            game_time.rotation_owner);

    if (am_i_winner) {
        if (timeout_calc_abandon_inner(op_context.last_block_time, opp_timeout_data.opp_last_heartbeat)) {

            _inner_game_timeout_finish_no_claim(maximal_game);

            // Opponent is inactive, and we are the winner.
            game_stats_claim_me_as_winner(maximal_game, game_end_type.CLEANUP);
            return true;
        } else {
            return false; // Opponent is active, must abort everything.
        }
    } else {
        // We're the loser and we terminate this game without even checking for timeout.
        //
        // Discussion: 
        // One could argue that this isn't in the player's best interest. 
        // Doing self-harm is typically not the way of blockchain, 
        // since blockchain users - according to game theory -
        // would not trigger any action that's bad for them.
        // But here we must assume that the player simply wants to play,
        // EVEN if (s)he will lose rating on this old one (which we cannot return to).
        _inner_game_timeout_finish_no_claim(maximal_game);

        game_stats_claim_opp_as_winner(maximal_game, game_end_type.CLEANUP);
        return true;
    }

}

// Finish the game.
function _inner_game_timeout_finish_no_claim(maximal_game: maximal_game_result) {
    // Note: we're not counting up the seed_count since no player can provide 
    // a seed (probably abandoned by both).
    update maximal_game.game (
        .is_finished = true, 
        // We don't count this as a claim since we don't have a seed.
        .finish_reason = game_end_type.CLEANUP); 
}

// Returns "true" if the player made the last move, and could be the winner.
// (If it was the opponent who made the last move, the current player can never win with a timeout).
function game_timeout_did_i_make_the_last_move(
    turn_nr: integer, 
    is_white: boolean, 
    my_p: player, 
    my_pg: player_game, 
    turn_owner: player_game
): boolean {
    if (turn_nr == 0) {
        // See Q2.1 above, we need to find black and make him the winner.
        // Note: We cannot trust the "turn_owner" here, since it's just the player who created the game (could be black or white).
        if (is_white) {
            return false; // We are white, we should lose
        } else {
            return true; // We are black, we should win
        }
    } else if (my_pg == turn_owner) { 
        return true; // This player made the last move => this player is the winner
    } else {
        return false; // Opponent made the last move, => this player is the loser
    }
}




