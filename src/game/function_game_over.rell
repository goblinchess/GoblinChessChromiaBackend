
// -------------------------------------
// There are two terms:
// - "ended" - the game is over, but we have not enough info to be certain who won (one or below seed verifications)
// - "terminated" - the game is over, and we know who won (two seed verifications)
// 
// Many games will never reach "terminated" state, since one of the players has shut down the client app or lost connection.
// -------------------------------------

// -------------------------------------
// End the game
// -------------------------------------

// -------------------------------------
// Finds if this move will "end" the game, and deals with it if this is the case.
//
// For some endings there is never any "claim" sent from the client, and we don't require any
// of the "move endings" to be calculated by the client, so we must be ready to fisish
// the game without a "claim" (meaning there is no random seed to validate), and both
// players will have to send their seeds later (when they discover that the game is over).
// 
// If we gave a seed, there are many ways this can turn out, but we don't know who 
// won until we verify the random numbers. Here we will verify the seed of the "claiming player". 
//   A) Seed Verification Success
//      What we do here is to create a "claim" on the result we're suggesting.
//      But many things can happen still:
//      A.1) If Checkmate, we give full points to the claiming player. The claiming player will 
//           keep the points UNLESS this is a timeout. If opponent claims timeout the claiming player 
//           will instead lose.
//      A.2) If Draw, we give the claiming FULL(!) points!
//           Only when the opponent send their seed the points will be divided between the players.
//           The timeout will agin cause the claiming player to lose.
//   B) Seed Verification Failure
//      It's pretty simple, for all situations the claiming player will lose the game. 
// 
// Note on 
// Remember that this player might deliver the mate AFTER timeout has occurred,
// so if the opponent challenges this result with a "timeout" claim, the winner might be switched. 
// => All we know at this point is that the game is over.
// -------------------------------------
function game_over_move_claim(
    minimal_game: minimal_game_result, 
    caller_pubkey: pubkey,
    new_turn: turn, 
    // Types of endings
    is_checkmate: boolean, 
    is_stalemate: boolean, 
    is_insufficient_mating_material: boolean,
    is_repetition: boolean,
    is_50_rule: boolean, // If true, we've broken the 50-move rule, the game is drawn.

    // Seed and signature if we have a claim.
    random_seed: integer?,
    seed_signature: byte_array?,
    player_rotation_descriptions: list<text>?
) :boolean {

    // Turn the flags into an [end_reason].
    var end_reason = game_end_type.NOTHING;
    if (is_checkmate) {
        end_reason = game_end_type.CHECKMATE;
    } else if (is_stalemate) {
        end_reason = game_end_type.STALEMATE;
    } else if (is_insufficient_mating_material) {
        end_reason = game_end_type.INSUFFICIENT_MATING_MATERIAL;
    } else if (is_repetition) {
        end_reason = game_end_type.MOVE_REPETITION;
    } else if (is_50_rule) {
        end_reason = game_end_type.MOVES_50;
    }

    if (end_reason != game_end_type.NOTHING) {

        log("game_id: " + minimal_game.game_id + " - Game Over, reason: " + end_reason);
        // This move ended the game

        // ------------------------------------------- 
        // 1. Update the time left
        // ------------------------------------------- 
        // Why bother? B/c the winning player might be out of time already.
        game_update_time_left(minimal_game);

        // ------------------------------------------- 
        // 2. Create the "game end" event (tied to this turn)
        // ------------------------------------------- 
        if (game_end_type_is_move_end(end_reason)) {
            // Only create this for the true move endings.
            event_game_end_create(minimal_game.game, new_turn, is_checkmate, is_stalemate, is_insufficient_mating_material);
        }

        // ------------------------------------------- 
        // 3. Set game status = fisished.
        // ------------------------------------------- 
        if (random_seed != null) { 
            require(seed_signature != null, "If you send the random_seed, you must also send seed_signature, id:" + minimal_game.game_id);
            require(player_rotation_descriptions != null, "If you send the random_seed, you must also send player_rotation_descriptions, id:" + minimal_game.game_id);

            val rot_desc_mega_str = util_text_join_list(player_rotation_descriptions);

            update minimal_game.game (
                .current_turn_nr = new_turn.number,  // Since this is caused by a move, we're updating the [current_turn_nr] to the latest.
                .is_finished = true, 
                .is_finished_by_claim = true,  // If they are sending the seed then this must be a "claim"
                .finish_reason = end_reason,
                .player_rotation_descriptions = rot_desc_mega_str);

            // ------------------------------------------- 
            // 4. Verify seed. The status of the verification will be saved to the [game]
            // ------------------------------------------- 
            game_over_first_inner_set_winner_and_loser_from_min_game(minimal_game, caller_pubkey, random_seed, seed_signature, end_reason);
        } else {
            // No seed means no claim.
            update minimal_game.game (
                .current_turn_nr = new_turn.number,  // Since this is caused by a move, we're updating the [current_turn_nr] to the latest.
                .is_finished = true, 
                .is_finished_by_claim = false, // Game is finished on the node's initiative (= not claimed)
                .finish_reason = end_reason);
            // Some client doesn't calculate mate and won't know the the game is over. 
            // These client will send the seed at some later point.
        }

        return true;
    } else {
        return false; // This move didn't end the game.
    }
}

// -------------------------------------
// Resign
// -------------------------------------

// -------------------------------------
// Will regign the game, validate the seed etc.
//
// What to do if the game is already over? (Could be that the opponent just resigned too or whatever.)
// Best is to simply terminate the game (by validate the seed etc) and don't report an error, since 
// we got the seed and it shouldn't go to waste.
// Remember, the player WANTED to end the game, so if it's already over that's a good thing.
// -------------------------------------
function game_over_resign(caller_pubkey: pubkey, game_id: integer, random_seed: integer, seed_signature: byte_array, player_rotation_descriptions: list<text>) {
    log("game_id: " + game_id.to_text() + " - started.");

    val (minimal_game: minimal_game_result?, g_end: game_end_data?) = minimal_game_and_end_data_get_even_if_finished(caller_pubkey, game_id);
    require(minimal_game != null, "Game not found, id:" + game_id);
    require(g_end != null, "Should not happen, id:" + game_id);

    if (g_end.is_finished) {
        // Best is to simply terminate the game (by validate the seed etc) and don't report an error, since 
        // we got the seed and it shouldn't go to waste.
        log("game_id: " + game_id.to_text() + " - game already ended, reason: " + g_end.finish_reason );

        // This will also validate if the game is already terminated (which cannot be explained, and would be a real error)
        game_terminate_maybe_with_seed(caller_pubkey, game_id, random_seed, seed_signature, player_rotation_descriptions);
    } else {
        // We don't care if the game is out of sync, since we might be doing this during the opponent's rotation anyways.
        val curr_turn = minimal_game.curr_turn_nr;
        log("game_id: " + game_id.to_text() + " - game ongoing, turn: " + curr_turn.to_text() + ". Ending it now");

        val rot_desc_mega_str = util_text_join_list(player_rotation_descriptions);

        // ... so no need setting the [current_turn_nr] here. 
        update minimal_game.game (
            .is_finished = true, 
            .is_finished_by_claim = true, // Must be a claim
            .finish_reason = game_end_type.RESIGNATION,
            .player_rotation_descriptions = rot_desc_mega_str);

        // Don't create [event_game_end], that's only when the game ends BECAUSE of a move.

        // As usual, we'll set ourself as winner, until the opponent provides their seed.
        game_over_first_inner_set_winner_and_loser_from_min_game(minimal_game, caller_pubkey, random_seed, seed_signature, game_end_type.RESIGNATION);
    }
}

// -------------------------------------
// Will resign the game with an error message, showing that this was not a volontary resignition.
//
// What to do if the game is already over? (Could be that the opponent just resigned too or whatever.)
// Best is to simply validate the seed and don't report an error, since 
// we got the seed and it shouldn't go to waste.
// Remember, the player WANTED to end the game, so if it's already over that's a good thing.
// -------------------------------------
function game_over_resign_with_error(caller_pubkey: pubkey, game_id: integer, random_seed: integer, seed_signature: byte_array, player_rotation_descriptions: list<text>, error_message: text) {
    log("game_id: " + game_id.to_text() + " - started");

    val (minimal_game: minimal_game_result?, g_end: game_end_data?) = minimal_game_and_end_data_get_even_if_finished(caller_pubkey, game_id);
    require(minimal_game != null, "Game not found, id:" + game_id);
    require(g_end != null, "Should not happen, id:" + game_id);

    if (g_end.is_finished) {
        // Best is to simply terminate the game (by validate the seed etc) and don't report an error, since 
        // we got the seed and it shouldn't go to waste.
        log("game_id: " + game_id.to_text() + " - game already ended, reason: " + g_end.finish_reason);

        // This will also validate if the game is already terminated (which cannot be explained, and would be a real error)
        game_terminate_maybe_with_seed(caller_pubkey, game_id, random_seed, seed_signature, player_rotation_descriptions);

        // If termination succeeded, we SHOULD be able to report the error too (even though it's not the reason the game ended)
        create game_error (minimal_game.game, minimal_game.player_game, error_type.CLIENT_ERROR_AFTER_END, error_message);

    } else {
        // We don't care if the game is out of sync, since we might be doing this during the opponent's rotation anyways.
        val curr_turn = minimal_game.curr_turn_nr;
        log("game_id: " + game_id.to_text() + " - game ongoing, turn: " + curr_turn.to_text() + ". Ending it now");

        val rot_desc_mega_str = util_text_join_list(player_rotation_descriptions);

        // ... so no need setting the [current_turn_nr] here. 
        update minimal_game.game (
            .is_finished = true, 
            .is_finished_by_claim = true, // Must be a claim
            .finish_reason = game_end_type.ERROR,
            .player_rotation_descriptions = rot_desc_mega_str);

        // Don't create [event_game_end], that's only when the game ends BECAUSE of a move.
        // and here the error could come from anywhere, like opponent's move for example.

        // As usual, we'll set ourself as winner, until the opponent provides their seed.
        game_over_first_inner_set_winner_and_loser_from_min_game(minimal_game, caller_pubkey, random_seed, seed_signature, game_end_type.ERROR);

        // Should be abole to save the error message
        create game_error (minimal_game.game, minimal_game.player_game, error_type.CLIENT_ERROR, error_message);
    }
}




