
// ----------
// Inspectors
// ----------


function game_is_classic(gt: game_type) :boolean {
    when (gt) {
        game_type.SPEED_5_CLASSIC -> return true;
        game_type.SPEED_10_CLASSIC -> return true;
        else -> return false;
    }
}

function game_type_to_time_left(gt: game_type) :integer {
    when (gt) {
        game_type.SPEED_5_CHAOTIC -> return 5 * 60 * 1000;
        game_type.SPEED_5_CLASSIC -> return 5 * 60 * 1000;
        game_type.SPEED_10_CHAOTIC -> return 10 * 60 * 1000;
        game_type.SPEED_10_CLASSIC -> return 10 * 60 * 1000;
    }
}


// Will find the player, the game and the color  from the player's pubkey
// This works since a player can only have one unfinished game at a time.
function minimal_game_data_get(player_pubkey: pubkey) :minimal_game_result? {
    // Return data
    val res = (p: player, pg: player_game, g: game)@?  {
        p.signer == player_pubkey, 
        pg.player == p, 
        g == pg.game,
        g.is_finished == false }
        (player = pg.player, player_game = pg, gme = g, game_type = g.game_type, curr_turn_nr = g.current_turn, 
        is_white = pg.is_white, in_check = pg.in_check, prev_move_time = g.last_move_finished_at);

    if (res != null) {
        return minimal_game_result(
            player = res.player,
            player_game = res.player_game,
            game = res.gme,
            game_type = res.game_type,
            curr_turn_nr = res.curr_turn_nr,
            in_check = res.in_check,
            is_white =res.is_white,
            prev_move_finished_at = res.prev_move_time
        );
    } else {
        return null;
    }
}

// -------------------------------------
// Will find the player, the game and the color 
// from the player's pubkey, even if the game is finished
//
// Note:
// We cannot use the function above, since when fetching the opponent's turn data, 
// we need to to see finished games since we MUST see the winning move, 
// event if the opponent just won the game and turned it into "finished".
// -------------------------------------
function minimal_game_data_get_even_if_finished(
    player_pubkey: pubkey, 
    game_id: integer // We need this, since the player usually has multiple finished games.
) :minimal_game_result? {
    // Return data

    val game_rowid = rowid(game_id);
    val res = (p: player, pg: player_game, g: game)@?  {
        p.signer == player_pubkey, 
        pg.player == p, // Not stricly needed, but I want to make sure some guy doesn't just ask for a random game.
        g == pg.game,
        g.rowid == game_rowid }
        (player = pg.player, player_game = pg, gme= g, game_type = g.game_type, curr_turn_nr = g.current_turn, 
        is_white = pg.is_white, in_check = pg.in_check, prev_move_time = g.last_move_finished_at);

    if (res != null) {
        return minimal_game_result(
            player = res.player,
            player_game = res.player_game,
            game = res.gme,
            game_type = res.game_type,
            curr_turn_nr = res.curr_turn_nr,
            in_check = res.in_check,
            is_white =res.is_white,
            prev_move_finished_at = res.prev_move_time
        );
    } else {
        return null;
    }
}


// ----------
// Updates
// ----------

// Will update the gome with:
// a. New turn number, (actually redundant, since the [turn] entity has been created)
// b. is_check = meaning we put the opponent in check.
// 
// Note: If we were in check in the beginning of this turn, 
// we don't bother to remove it, since the opponent will 
// update our is_check status in the end of their move.
function game_update_turn_and_check_status(minimal_game: minimal_game_result, new_turn: turn, is_check: boolean) {
    // 1. Update game with new turn number
    update minimal_game.game (.current_turn = new_turn.number);

    // 2. Find opponent [player_game]
    val opponent_player_game = player_game@ {
        .game == minimal_game.game,
        .is_white != minimal_game.is_white 
    };

    // 3. Update opponent [player_game] with new is_check status
    update opponent_player_game (.in_check = is_check);
}


// Update the [time_left] field for the player_game entity.
// We do this at the very last moment, usually when the player 
// sends the "neutral_skip" move.
function game_update_time_left(minimal_game: minimal_game_result) {
    val curr_time_milli_sec = op_context.last_block_time; // Only way for us to measure time.
    val real_time_consumed_milli_sec =  curr_time_milli_sec - minimal_game.prev_move_finished_at;

    // We give the player two extra seconds per turn, since animations take time, blockchain build etc.
    val time_consumed_milli_sec = real_time_consumed_milli_sec - 2000; // Doesn't matter if this is negative, a player should be able to GAIN time if fast.

    // TODO: Remove this, too expensive
    val real_game_time_tot = curr_time_milli_sec - minimal_game.game.created_at;
    val real_game_time_tot_secs = real_game_time_tot / 1000;

    val real_secs = real_time_consumed_milli_sec / 1000;
    val secs = time_consumed_milli_sec / 1000;
    log("Gametime tot: " + real_game_time_tot_secs + ". Player consumed: " + real_secs + " seconds doing this turn, but we reduce it to " + secs + " seconds.");

    // Yes, we could use the timestamp from the [turn], but it's more convenient to 
    // keep this data in the [game] entity.
    update minimal_game.game (.last_move_finished_at = curr_time_milli_sec);

    // Update the time left for the player
    // NOTE: If this becomes negative, it will be the opponent's task to call "timeout" 
    update minimal_game.player_game (.time_left -= time_consumed_milli_sec);
}


// -------------------------------------
// First, we don't know who won until we verify the random numbers.
// Second, remember that this player might deliver the mate AFTER timeout has occurred,
// so if the opponent challenges this result with a "timeout" claim, the winner might be switched. 
// => All we know at this point is that the game is over.
// -------------------------------------
function game_over(minimal_game: minimal_game_result, new_turn: turn, is_checkmate: boolean, is_stalemate: boolean) :boolean {
    if (is_checkmate or is_stalemate) {
        log("Game Over");
        if (is_checkmate) {
            _inner_game_terminate_checkmate(minimal_game.game, new_turn.number, minimal_game.player_game);
            game_update_time_left(minimal_game);
        } else {
            // Stalemate
            _inner_game_terminate_draw(minimal_game.game, new_turn.number, minimal_game.player_game);
            game_update_time_left(minimal_game);
        }

        return true;
    } else {
        return false;
    }
}

// -------------------------------------
// Terminate any old game
//
// We will look for any old ongoing game and terminate it.
// 
// Background/Requirements:
// Before a player can enter the lobby (s)he must terminate any old (unfinished) game
// (since there can only be one ongoing game per player).
//
// Q1: Why cannot the player just keep playng the unfinished game?
// A1: Because the client is still too stupid to put everything on the correct place, and this way start 
//     where the old game left off. Therefore we need to terminate ANY old game we find.
//     In v2.0 this might change.
// 
// Q2: But who should win? 
// A2: The player (A) who made the last move should win, since we can safely assume the other player (B) "escaped" 
//     (shut down the computer or something), or else player B would have made a move AFTER player A's last move.
//     (The correct way to escap is via the "Resign" button, but we must assume some players won't show sportmanship.)
//
// Q2.1: But if nobody made a move?
// A2.1: Then black is the winner and white is the loser (sicne white should have moved).
// 
// Q3: Some Chess games allow quitting during the first move without ELO penalty (i.e. was made there was NO game).
//     Why can't we allow closing of the game early on without ELO penalty?
// A3: In GoblinChess would means that if either player doesn't like his/her cards they can just leave and 
//     won't lose rating. This could lead to a majority of games being aborted early on, so we don't allow it.
// 
// Q4: What if a player (A) makes a move, quickly shuts down the GoblinChess client, 
//     starts the client again, and starts a new game? This way the old game is terminated, 
//     declaring player A as the winner (the last player to make a move).
// A4: Yes, this is indeed a threat. But remember, player A must do all this before player B makes a move.
//     or else player B will win. Unlikely Player A can cheat this way, but we want to make sure that 
//     the opponent gets at least two minutes to make a move. 
// -------------------------------------

function game_terminate_if_old(me: player) {
    val maybe_game = (pg: player_game, g: game, pg_opp: player_game, ct: current_turn, t: turn)@? {
        pg.player == me,
        pg.game == g,
        pg_opp.player != me,
        pg_opp.game == g,
        g.is_finished == false,
        ct.game == g,
        ct.current_turn == t // yes, even if we are at turn = 0 there will be a [current_turn] row.
    } (gme = g, 
        my_pg = pg, opp_pg = pg_opp, 
        my_p = pg.player, opp_p = pg_opp.player, 
        my_name = pg.player.name, opp_name = pg_opp.player.name,
        my_elo = pg.player.elo_rating, opp_elo = pg_opp.player.elo_rating,
        turn_owner = t.created_by, turn_nr = t.number,
        black_player = g.black_player);

    if (maybe_game != null) {

        var am_i_winner = false;
        if (maybe_game.turn_nr == 0) {
            // See Q2.1 above, we need to find black and make him the winner.
            // Note: We cannot trust the "turn_owner" here, since it's just the player who created the game (could be black or white).
            if (maybe_game.black_player == maybe_game.my_p) {
                am_i_winner = true; // We are black, we should win
            } else {
                am_i_winner = false; // We are white, we should lose
            }
        } else if (maybe_game.my_pg == maybe_game.turn_owner) {
            am_i_winner = true; // This player made the last move => this player is the winner
        } else {
            am_i_winner = false; // Opponent made the last move, => this player is the loser
        }

        if (am_i_winner) {
            _inner_game_terminate_timeout(maybe_game.gme, 
                maybe_game.my_p, maybe_game.opp_p,
                maybe_game.my_pg, maybe_game.opp_pg,
                maybe_game.my_name, maybe_game.opp_name,
                maybe_game.my_elo, maybe_game.opp_elo
            );
        } else {
            _inner_game_terminate_timeout(maybe_game.gme, 
                maybe_game.opp_p, maybe_game.my_p, 
                maybe_game.opp_pg, maybe_game.my_pg, 
                maybe_game.opp_name, maybe_game.my_name, 
                maybe_game.opp_elo, maybe_game.my_elo
            );
        }
    }
}

// -------------------------------------
// We will never get a chance to validate the random numbers,
// so we can go ahead and create the [player_game_stats] record
// immediately, but with empty [player_seed].
// -------------------------------------
function _inner_game_terminate_timeout(gme: game, 
    winner_p: player, loser_p: player, 
    winner_pg: player_game, loser_pg: player_game, 
    winner_name: text, loser_name: text, 
    winner_old_elo: integer, loser_old_elo: integer
) {

    update gme (.is_finished = true, .is_draw = false);

    // Timeout is just like any other win.
    val (winner_new_elo, loser_new_elo) = elo.update_chess_ratings_on_win(winner_old_elo, loser_old_elo);

    val created_time = op_context.last_block_time;

    // Create Winner's stats
    create player_game_stats (
        .player_game = winner_pg,
        .game = gme,
        .player = winner_p,
        .is_winner = true,
        .is_draw = false, 
        .is_timeout = true, 
        .is_error = false, // Timeout isn't considered an error
        .new_elo_rating = winner_new_elo, // The new ELO rating after the game.
        .player_seed = byte_array(''), // Cannot be null, but doesn't matter what it is.
        .opp_name = loser_name,
        .opp_elo = loser_old_elo, // Here it only matters what the opponent's ELO was when the game started
        .created_at = created_time
    );

    // Create Loser's stats
    create player_game_stats (
        .player_game = loser_pg,
        .game = gme,
        .player = loser_p,
        .is_winner = false,
        .is_draw = false, 
        .is_timeout = true, 
        .is_error = false, // Timeout isn't considered an error
        .new_elo_rating = loser_new_elo, // The new ELO rating after the game.
        .player_seed = byte_array(''), // Cannot be null, but doesn't matter what it is.
        .opp_name = winner_name,
        .opp_elo = winner_old_elo, // Here it only matters what the opponent's ELO was when the game started
        .created_at = created_time
    );
}

// We cannot create [player_game_stats] at this point, since we must verify the random numbers first.
function _inner_game_terminate_checkmate(gme: game, curr_turn_nr: integer, winner_pg: player_game) {
    update gme (.current_turn = curr_turn_nr, .is_finished = true, .is_draw = false);

}

// We cannot create [player_game_stats] at this point, since we must verify the random numbers first.
function _inner_game_terminate_draw(gme: game, curr_turn_nr: integer, winner_pg: player_game) {
    update gme (.current_turn = curr_turn_nr, .is_finished = true, .is_draw = true);
}