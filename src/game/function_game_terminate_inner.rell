// -------------------------------------------------------------------------
// We terminate the game with the given seed.
// Here we expect that exactly one seed has been validated already.
//
// We don't care if the game is out of sync, since we might be doing this during 
// the opponent's rotation anyways.
// -------------------------------------------------------------------------
function game_terminate_inner_with_seed (caller_pubkey: pubkey, game_id: integer, random_seed: integer, seed_signature: byte_array, 
    max_game: maximal_game_result, g_end_data: game_end_data, finish_reason: game_end_type)  
{
    val tot_seeds = g_end_data.valid_seeds_count + g_end_data.invalid_seeds_count;
    require(tot_seeds == 1, "We expected the game to have exactly one seed, but found " + tot_seeds + " seeds?, id:" + game_id); 

    // Let's check if WE ended the game?
    val my_stored_seeds = (s: player_game_seed)@* {s.player_game == max_game.my_pg} (s.validation_success);
    require(my_stored_seeds.size() == 0, "You have already sent your random seed so you cannot terminate this game, opponent must terminate with seed, id:" + game_id); 

    var opp_validation_success = false;
    if (g_end_data.invalid_seeds_count == 0) { // Since the provided seed must be the opponent's we can assume "no invalid" means success.
        opp_validation_success = true;
    }

    // ----------------
    // B.1. Validate the seed
    // ----------------
    val seed_input = seed_validation_input(
        pubk = caller_pubkey,
        seed_material = max_game.seed_material,
        org_seed = random_seed,
        seed_signature = seed_signature
    );
    // We don't use "require()" on this, since we want to save 
    // the seed even if it's wrong. This means that the client wont
    // get any feedback if the wrong seed was sent.
    val x = rnd_validation_of_player(
        game_id = max_game.game_id,
        g_type = max_game.game_type,
        g = max_game.game,
        pg = max_game.my_pg,
        seed_input = seed_input
    );

    val my_validation_success = x == null;

    if (my_validation_success) {
        if (opp_validation_success) {
            // Standard case. The "game.finish_reason" should determine who won.
            log("game_id: " + game_id + " - Both opponent and you sent valid seeds");
            game_stats_use_finish_reason(finish_reason, max_game);
        } else {
            log("game_id: " + game_id + " - Your seed is valid, but the opponent sent an invalid seed (you are already set as winner so we do nothing)");
            // Don't change the [player_game_stats] data, this player is already set as winner.
        }
    } else {
        if (opp_validation_success) {
            // The opponent's claim should stand. 
            log("game_id: " + game_id + " - Opponent sent a valid seed, but yours is bad (you are already set as loser so we do nothing), err: " + x);
            // Don't change the [player_game_stats] data, this player is already set as loser.
        } else {
            // Both failed! Should be extremely unusual, unless we are swamped by broken bots.
            // Doesn't matter who gets the win since both are cheaters, but let's make it a draw.
            log("game_id: " + game_id + " - Both opponent and you sent invalid seeds!? Calling it a draw, err: " + x);
            game_stats_terminate_draw_2_fails(max_game);
        }
    }


}