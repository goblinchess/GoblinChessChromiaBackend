// All these "board_" functions work with the BOARD_POSITIONS_ALL struct.
// TODO: Could have made a namespace for this.


// Returns a BOARD_POSITIONS_ALL struct.
function build_board_positions_all(
    game: game, 
    board: list<with_pos_and_alignment>, 
    portal_list: list<owned_portal>
): board_positions_all {

    // 1. Split the board into pieces and obstacles.
    val pieces = map<integer, with_pos_and_alignment>();
    val obstacles = map<integer, with_pos_and_alignment>();

    for (v in board) {
        if (v.alignment == alignment.NEUTRAL) {
            obstacles[v.pos] = v;
        } else {
            pieces[v.pos] = v;
        }
    }

    // 2. Return the struct
    return board_positions_all(
        board_characters = pieces, 
        board_obstacles = obstacles,
        portals = portal_list
    );
}

// ----------------
// Yes/No queries
// ----------------

function board_is_empty(board_positions_all, pos: integer): boolean {
    require(piece_is_pos_on_board(pos), "Illegal position: " + pos);
    
    if (board_positions_all.board_characters.contains(pos)) {
        return false;
    }
    if (board_positions_all.board_obstacles.contains(pos)) {
        return false;
    }
    return true;
}

function board_is_free_at(board_positions_all, pos: square_pos): boolean {
    return board_get_square_status(board_positions_all, pos) == square_status.FREE;
}


function board_is_white_piece_at(board_positions_all, pos: square_pos): boolean {
    return board_get_square_status(board_positions_all, pos) == square_status.WHITE_PIECE;
}

function board_is_black_piece_at(board_positions_all, pos: square_pos): boolean {
    return board_get_square_status(board_positions_all, pos) == square_status.BLACK_PIECE;
}

function board_is_attackable_black_or_neutral_at(board_positions_all, pos: square_pos): boolean {
    val stat = board_get_square_status(board_positions_all, pos);
    return stat == square_status.BLACK_PIECE or 
           stat == square_status.NEUTRAL_PIECE or 
           stat == square_status.OBSTACLE;
}

function board_is_attackable_white_or_neutral_at(board_positions_all, pos: square_pos): boolean {
    val stat = board_get_square_status(board_positions_all, pos);
    return stat == square_status.WHITE_PIECE or 
           stat == square_status.NEUTRAL_PIECE or 
           stat == square_status.OBSTACLE;
}

// ----------------
// Getters
// ----------------
function board_get_at(board_positions_all, pos: integer): with_pos_and_alignment? {
    require(piece_is_pos_on_board(pos), "Out of board " + pos);

    if (board_positions_all.board_characters.contains(pos)) {
        return board_positions_all.board_characters[pos];
    } else if (board_positions_all.board_obstacles.contains(pos)){
        return board_positions_all.board_obstacles[pos];
    } else {
        return null;
    }
}

function board_get_square_status(board_positions_all, pos: square_pos): square_status {
    val pos_int = pos_to_int(pos);
    return board_get_square_status_int(board_positions_all, pos_int);
}

function board_get_square_status_int(board_positions_all, pos: integer): square_status {
    if (piece_is_pos_out_of_board(pos)) {
        return square_status.OUT_OF_BOARD;
    }
    
    if (board_positions_all.board_characters.contains(pos)) {
        val found = board_positions_all.board_characters[pos];
        return align_piece_to_square_status(found.alignment); // BLACK, WHITE or NEUTRAL
    } else if (board_positions_all.board_obstacles.contains(pos)){
        return square_status.OBSTACLE; // Easy
    } else {
        return square_status.FREE; // Easy
    }
}


// ----------------
// Mutators
// ----------------

// Moving a piece from one position to another
function board_place_character_at(
    board: board_positions_all,
    from_pos: integer,
    dest_pos: integer,
    old_piece: with_pos_and_alignment
) {
    // Convert square positions to integers
    //val from_pos_int = pos_to_int(from_pos);
    //val dest_pos_int = pos_to_int(dest_pos);

    // We MUST remove anything on the dest_pos before we do this.
    require(board_is_empty(board, dest_pos), "Destination position is not empty: " + dest_pos);

    val new_piece = with_pos_and_alignment(dest_pos, old_piece.alignment);

    board.board_characters.remove(from_pos);
    board.board_characters[dest_pos] = new_piece;
}

// Whatever is on the given position, remove it.
function board_remove_at(
    board: board_positions_all,
    pos: integer
) {
    require(not board_is_empty(board, pos), "Destination position is not empty: " + pos);

    if (board.board_characters.contains(pos)) {
        board.board_characters.remove(pos);
    } else if (board.board_obstacles.contains(pos)) {
        board.board_obstacles.remove(pos);
    } else {
        require(false, "Internal error: we already checked the board.");
    }
}

// ----------------
// Portals 
// ----------------

// Returns a portal if:
// a) the given pos is a portal entry,
// b) the portal is owned by me
// c) the exit isn't blocked.
function board_is_unblocked_portal_at(
    board_positions_all, 
    pos: integer, 
    align: alignment
): owned_portal? {
    val portal = board_find_my_portal_from_entry(board_positions_all, pos, align);
    if (portal != null) {
        // NOT SO FAST. We can only use it if the exit is empty.
        if (board_is_empty(board_positions_all, portal.exit_pos)) {
            return portal;
        } else { 
            return null;
        }
    } else {
        return null;
    }
}


// Do we have a portal owned by "my_align" that has "pos" as its entry point?
function board_find_my_portal_from_entry(
    board_positions_all, 
    pos: integer, 
    align: alignment
) {
    for (portal: owned_portal in board_positions_all.portals) {
        if (is_portal_owned_by(portal, align)) {
            if (portal.entry_pos == pos) {
                return portal;
            }
        }
    }
    return null;
}

// --------------------------------------
// Returns all portals where:
// b) the portal is owned by me
// c) the exit isn't blocked.
// --------------------------------------
function board_find_unblocked_portals_owned_by(
    board_positions_all, 
    my_align: alignment
): list<owned_portal> {
    val result = list<owned_portal>();
    
    for (portal in board_positions_all.portals) {
        if (is_portal_owned_by(portal, my_align)) {
            // It's ours
            if(board_is_empty(board_positions_all, portal.exit_pos)) {
                // Exit is unblocked
                result.add(portal); 
            }
        }
    }
    
    return result;
}

// ------------------------
// Searches any of the 0-3 ranks
// ------------------------

// We that the squeare we'll be looking for is on white's side.
function board_verify_empty_square_white_side(
    board_positions_all,
    portal_exit_pos: integer,
    rnd_data
): rnd_result
{
    return board_verify_side( board_positions_all, 0, portal_exit_pos, rnd_data);
}

// ------------------------
// Searches any of the 4-7 ranks
// ------------------------
// We that the squeare we'll be looking for is on black's side.
function board_verify_empty_square_black_side(
    board_positions_all, 
    portal_exit_pos: integer,
    rnd_data
): rnd_result
{
    return board_verify_side(board_positions_all, 4, portal_exit_pos, rnd_data);
}

// Will verify if the given random number indeed corresponds to the given portal exit pos.
function board_verify_side(
    board_positions_all,
    add_to_y: integer, // Determine the Y offset based on the side
    portal_exit_pos: integer,
    rnd_data
): rnd_result {

    // ------------------------
    // 1. Build the list of empty positions
    // ------------------------
    val empty_positions = list<integer>();

    // Loop through ranks and add empty positions
    for (y_temp in range(0, 4)) {
        val y_real = y_temp + add_to_y;
        add_all_empty_at_rank_y(board_positions_all, y_real, empty_positions);
    }
    // ------------------------
    // 2. Validation
    // ------------------------

    // Sanity check: Must be at least one empty position on each side of the board.
    // Yes, theoretically, this can happen. If we put multiple walls on one side, AND
    // move opponents pieces to this side to fill it up completely. 
    // But that would lead to stalemate, so it's not going to.
    // Also, the client wouldn't be able to cast this spell if this was the case.
    val total_empty_positions = empty_positions.size();
    require(total_empty_positions > 0, "board_search_side() - Impossible for one side to be full.");

    val empty_pos_max_indx = total_empty_positions - 1;
    require(rnd_data.min == 0, "For portal the MIN should be 0, client gave: " + rnd_data.min);
    require(rnd_data.max == empty_pos_max_indx, "For portal the node calculates MAX to be " + empty_pos_max_indx + 
        ", but client gave: " + rnd_data.max);
    require(0 <= rnd_data.result and rnd_data.result <= empty_pos_max_indx, "Client gave: " + rnd_data.result + 
        " which is out of bounds (MIN: 0, MAX: " + empty_pos_max_indx + ")");

    // Let's validate that the given random number indeed corresponds to the given position in our list.
    val calculated_exit_pos = empty_positions[rnd_data.result];
    require(calculated_exit_pos == portal_exit_pos, "The calculated exit position " + calculated_exit_pos + 
        " does not match the given exit position "+ portal_exit_pos +".");
            
    return rnd_result(
        result = rnd_data.result, 
        type = rnd_nr_type.CARD_PORTAL, // <-- Only use case 
        min = rnd_data.min, 
        max = rnd_data.max 
    );
}

function add_all_empty_at_rank_y(
    board_positions_all, 
    y: integer, // The rank we are looking at 
    empty_positions: list<integer> // Where we put all found empty positions
) {
    for (x in range(0, 8)) {
        val pos_sq = square_pos(x, y);
        val pos: integer = pos_to_int(pos_sq);
        if (board_is_empty(board_positions_all, pos)) {
            empty_positions.add(pos);
        }
    }
}