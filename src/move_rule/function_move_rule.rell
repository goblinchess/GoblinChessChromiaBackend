

// ----------------------------------------------------------------------------
// Base functions for move rules
// ----------------------------------------------------------------------------

// Helper function to interpret a path position
function rule_interpret_path_position(
    board_positions: board_positions_all,
    align: alignment,
    new_pos: integer,
    tmp_path: list<integer>,
    pre_tree: pre_tree
): boolean {
    val ss = board_get_square_status_int(board_positions, new_pos);
    
    when (ss) {
        square_status.FREE -> {
            pre_tree.movable_sqs.add(new_pos);
            tmp_path.add(new_pos);
            return true; // Free space is not blocking, continue on path
        }
        square_status.BLACK_PIECE -> {
            if (align == alignment.WHITE or align == alignment.NEUTRAL) {
                // White can attack
                pre_tree.attackable_sqs.add(new_pos);
                tmp_path.add(new_pos);
                pre_tree.paths.add(path_base(tmp_path, path_type.GROUND_ATTACK));
            } else if (tmp_path.size() > 1) {
                // Black protected by another black
                pre_tree.protected_sqs.add(new_pos);
                pre_tree.paths.add(path_base(tmp_path, path_type.GROUND_MOVE));
            }
            return false;
        }
        square_status.WHITE_PIECE -> {
            if (align == alignment.BLACK or align == alignment.NEUTRAL) {
                // Black can attack
                pre_tree.attackable_sqs.add(new_pos);
                tmp_path.add(new_pos);
                pre_tree.paths.add(path_base(tmp_path, path_type.GROUND_ATTACK));
            } else if (tmp_path.size() > 1) {
                // White protected by white
                pre_tree.protected_sqs.add(new_pos);
                pre_tree.paths.add(path_base(tmp_path, path_type.GROUND_MOVE));
            }
            return false;
        }
        square_status.NEUTRAL_PIECE, square_status.OBSTACLE -> {
            // Everyone can attack neutral/obstacle
            pre_tree.attackable_sqs.add(new_pos);
            tmp_path.add(new_pos);
            pre_tree.paths.add(path_base(tmp_path, path_type.GROUND_ATTACK));
            return false;
        }
        else -> {
            // Obstacle or out of board
            if (tmp_path.size() > 1) {
                pre_tree.paths.add(path_base(tmp_path, path_type.GROUND_MOVE));
            }
            return false;
        }
    }
}

// Helper function for single step interpretation
function rule_interpret_single_step_position(
    board_positions: board_positions_all,
    align: alignment,
    new_pos: integer,
    tmp_path: list<integer>,
    pre_tree: pre_tree,
    is_jump: boolean
) {
    //log ("rule_interpret_single_step_position(" + new_pos + ")");
    val ss = board_get_square_status_int(board_positions, new_pos);
    
    when(ss) {
        square_status.FREE -> {
            pre_tree.movable_sqs.add(new_pos);
            tmp_path.add(new_pos);
            _add_move_to_paths(tmp_path, is_jump, pre_tree.paths);
        }
        square_status.BLACK_PIECE -> {
            if (align == alignment.WHITE or align == alignment.NEUTRAL) {
                pre_tree.attackable_sqs.add(new_pos);
                tmp_path.add(new_pos);
                _add_attack_to_paths(tmp_path, is_jump, pre_tree.paths);
            } else {
                pre_tree.protected_sqs.add(new_pos);
            }
        }
        square_status.WHITE_PIECE -> {
            if (align == alignment.BLACK or align == alignment.NEUTRAL) {
                pre_tree.attackable_sqs.add(new_pos);
                tmp_path.add(new_pos);
                _add_attack_to_paths(tmp_path, is_jump, pre_tree.paths);
            } else {
                pre_tree.protected_sqs.add(new_pos);
            }
        }
        square_status.NEUTRAL_PIECE, square_status.OBSTACLE -> {
            pre_tree.attackable_sqs.add(new_pos);
            tmp_path.add(new_pos);
            _add_attack_to_paths(tmp_path, is_jump, pre_tree.paths);
        }
        else -> {
            // Out of board, do nothing
        }
    }
}

// Helper functions for path management
function _add_move_to_paths(tmp_path: list<integer>, is_jump: boolean, paths: list<path_base>) {
    if (is_jump) {
        paths.add(path_jump_move(tmp_path));
    } else {
        paths.add(path_base(tmp_path, path_type.GROUND_MOVE));
    }
}

function _add_attack_to_paths(tmp_path: list<integer>, is_jump: boolean, paths: list<path_base>) {
    if (is_jump) {
        paths.add(path_jump_attack(tmp_path));
    } else {
        paths.add(path_base(tmp_path, path_type.GROUND_ATTACK));
    }
}

// Helper function for pre-obstacle path interpretation
// Returns a tuple of (continue, obstacle_found)
function rule_interpret_path_position_pre_obstacle(
    board_positions: board_positions_all,
    new_pos: square_pos 
): (boolean, boolean) {
    val ss = board_get_square_status(board_positions, new_pos);
    
    when(ss) {
        square_status.FREE -> {
            return (true, false); // Continue path, no obstacle found
        }
        square_status.BLACK_PIECE, 
        square_status.WHITE_PIECE,
        square_status.NEUTRAL_PIECE,
        square_status.OBSTACLE -> {
            return (true, true); // Continue path, obstacle found
        }
        else -> {
            return (false, false); // Out of board, stop path
        }
    }
}

// Helper function for post-obstacle path interpretation
function rule_interpret_path_position_post_obstacle(
    board_positions: board_positions_all,
    align: alignment,
    start_pos: integer,
    new_pos: integer,
    pre_tree: pre_tree
): boolean {
    val ss = board_get_square_status_int(board_positions, new_pos);
    
    when(ss) {
        square_status.FREE -> {
            pre_tree.movable_sqs.add(new_pos);
            pre_tree.paths.add(path_jump_move_2(start_pos, new_pos));
            return true; // Free space is not blocking, continue on path
        }
        square_status.BLACK_PIECE -> {
            if (align == alignment.WHITE or align == alignment.NEUTRAL) {
                // We can attack
                pre_tree.attackable_sqs.add(new_pos);
                pre_tree.paths.add(path_jump_attack_2(start_pos, new_pos));
            }
            return false;
        }
        square_status.WHITE_PIECE -> {
            if (align == alignment.BLACK or align == alignment.NEUTRAL) {
                // Enemy can attack us
                pre_tree.attackable_sqs.add(new_pos);
                pre_tree.paths.add(path_jump_attack_2(start_pos, new_pos));
            }
            return false;
        }
        square_status.NEUTRAL_PIECE, square_status.OBSTACLE -> {
            // Everyone can attack neutral/obstacle
            pre_tree.attackable_sqs.add(new_pos);
            pre_tree.paths.add(path_jump_attack_2(start_pos, new_pos));
            return false;
        }
        else -> {
            return false; // Out of board, stop path
        }
    }
}
