// -------------------------------------
// Inspectors
// -------------------------------------

// Returns the last seen turn type and its number.
function get_current_turn(game: game): (trn: turn, t_type: turn_type, t_number: integer, rotation_nr: integer, p_rotation: player_rotation) {
    return (ct: current_turn, t: turn, r: player_rotation)@ {
        ct.game == game,
        ct.current_turn == t,
        t.player_rotation == r
    } (trn = t, 
       t_type = t.turn_type, 
       t_number = t.number, 
       rotation_nr = r.rotation_nr, 
       p_rotation = r);
}

function turn_is_first_of_rotation(tt: turn_type): boolean {
    when (tt) {
        turn_type.WHITE_CARD,
        turn_type.WHITE_CARD_SKIPPED,
        turn_type.BLACK_CARD,
        turn_type.BLACK_CARD_SKIPPED
          -> return true;
        else -> return false;
    }
}

// Returns "true" if this is the last turn of a double move.
function turn_is_last_double_move(tt: turn_type): boolean {
    return tt == turn_type.NEUTRAL_MOVE_1_HIJACKED or tt == turn_type.NEUTRAL_MOVE_2_HIJACKED;
}

function turn_is_last_of_rotation(tt: turn_type): boolean {
    when (tt) {
        turn_type.NEUTRAL_MOVE_1,
        turn_type.NEUTRAL_MOVE_1_SKIPPED,
        turn_type.NEUTRAL_MOVE_1_HIJACKED,
        turn_type.NEUTRAL_MOVE_2,
        turn_type.NEUTRAL_MOVE_2_SKIPPED,
        turn_type.NEUTRAL_MOVE_2_HIJACKED
          -> return true;
        else -> return false;
    }
} 

// -------------------------------------
// Creators
// -------------------------------------

// Creates the first turn for a game
function turn_create_first(g: game, creatoor: player_game): turn {

    // Validation 
    val check = turn@? {g};
    require(check == null, "Game: " + g.rowid.to_integer() + " already has a turn.");

    // Creation 

    val new_rotation = create player_rotation(
        .game = g,
        .rotation_nr = 0, // Before first turn
        .created_by = creatoor,
        .created_at = op_context.last_block_time
    );

    val new_turn = create turn(
        .game = g,
        .number = 0,
        .turn_type = turn_type.FRESH_GAME, // This is the turn BEFORE anything has happened.
        .player_rotation = new_rotation,
        .created_at = op_context.last_block_time
    );

    // First turn we must create this
    create current_turn(.current_turn = new_turn, .game = g);

    return new_turn;
}

// -------------------------------------
// Returns 
// 1) the new turn, 
// 2) new turn nr, 
// 3) last rot nr
//
// When we create a (non first) turn, we must also send the TURN_TYPE, 
// and the PLAYER_COLOR (that is the color of the player that is playing).
// These values must be validated, to detect if the client playing out of turn.
// -------------------------------------
function turn_create(
    gme: game, 
    created_by: player_game, 
    new_t_type: turn_type, 
    is_white: boolean, 
    is_pawn_move_or_capture: boolean
): (turn, integer, integer, turn, turn_type) {

    // Validation 
    val (old_turn: turn, old_t_type: turn_type, old_t_number: integer, old_r_number: integer, old_p_rotation: player_rotation) = get_current_turn(gme);

    val err: text? = verify_old_turn_type_new_turn_type(gme, created_by, old_t_type, new_t_type, old_t_number, is_white);
    if (err != null) {
        require(false, err);
    }

    // Do we need a new rotation? This will potentially create a new rotation if needed.
    val (new_rotation_nr: integer, new_rotation: player_rotation) = rotation_maybe_create( gme, created_by, new_t_type, old_t_number, old_r_number, old_p_rotation);

    // Creation
    val new_turn_nr = old_t_number + 1;
    val new_turn = create turn(
        .game = gme,
        .number = new_turn_nr,
        .turn_type = new_t_type,
        .player_rotation = new_rotation,
        .created_at = op_context.last_block_time
    );

    update current_turn@ {gme} (.current_turn = new_turn);

    //GAME cannot have a reference to the (current) TURN since we don't allow two-way FKs.
    update gme (.current_rotation_nr = new_rotation_nr, .current_turn_nr = new_turn_nr);  
    if (is_pawn_move_or_capture) {
        update gme (.last_turn_when_pawn_advanced = new_turn_nr); // For the 50-move rule  
    }

    // ---------------------------------------------------------------------------------------
    // Update both players' last heartbeat (must be done every time a player does something).
    // 
    // Explanation:
    // It's obvious why we would why we would update the "active" player (= the player now taking action), 
    // but why do we update for the PASSIVE player too? The reason is simple: it's obviously not the 
    // passive player's turn, so the heartbeat (abandon) counter should begin the clock from when we 
    // switched to the (now passive) player's turn.
    // ---------------------------------------------------------------------------------------
    game_timeout_set_both_player_alive(gme);

    return (new_turn, new_turn_nr, new_rotation_nr, old_turn, old_t_type);
}


