

// -------------------------------------
// Debug queries
// -------------------------------------
query get_players() {
    return player@* {};
}

query get_player_names() {
    return player@* {} (.name);
}

query get_player_by_name(search_name: text) {
    return player@? {.name == search_name} (.signer);
}

// -------------------------------------
// Lobby 
// -------------------------------------

query consume_lobby_entry(
    player_signer: pubkey,  // The player's own pubkey
    curr_ms: timestamp,
    game_type_str: text) :pubkey? {

    // Get the requesting player
    val requesting_player = player@{.signer == player_signer};
    
    return get_lobby_entry_inner(requesting_player, game_type_str, curr_ms);
}

query consume_lobby_entry_by_name(
    player_name: text,
    curr_ms: timestamp,
    game_type_str: text) :pubkey? {

    val requesting_player = player@{.name == player_name};

    return get_lobby_entry_inner(requesting_player, game_type_str, curr_ms);
}




// -------------------------------------
// In Game query
// -------------------------------------

query in_game (
   player_signer: pubkey // The player's own pubkey
) :in_game_result? {

    val minimal_game: minimal_game_result? = minimal_game_data_get(player_signer);

    if (minimal_game == null) {
        return null;
    } else {
        val g_data = game@ {.rowid == minimal_game.game.rowid} (.rowid, .black_player, .white_player, .created_at);


        val plays_white = minimal_game.is_white;
        var opp: player? = null;
 
        if (plays_white) {
            opp = g_data.black_player;
        } else {
            opp = g_data.white_player;
        }

        return in_game_result(
            game_rowid = g_data.rowid.to_integer(),
            game_type = minimal_game.game_type,
            is_white = plays_white,
            opponent_pubkey = opp.signer,
            opponent_name = opp.name,
            opponent_elo = opp.elo_rating,
            curr_turn_nr = minimal_game.curr_turn_nr,
            created_at = g_data.created_at
        );
    }
}

// -------------------------------------
// Old games
//
// The player wants to see his/her of old games:
// a) who (s)he played against (elo, name),
// b) who won,
// c) what happened to the ELO rating.
// -------------------------------------
query get_old_games(
    player_signer: pubkey
): list<old_game_stat> {
    val results =  (p_my: player, pgs_my: player_game_stats)@* {
        p_my.signer == player_signer,
        pgs_my.player == p_my
    } (
        game_rowid = pgs_my.game.rowid, 
        @sort_desc crt_at = pgs_my.created_at,
        opp_name = pgs_my.opp_name,
        opp_elo = pgs_my.opp_elo,
        new_elo = pgs_my.new_elo_rating,
        winner = pgs_my.is_winner,
        draw = pgs_my.is_draw,
        timeout = pgs_my.is_timeout,
        error = pgs_my.is_error
    ) limit 100;

    val return_list = list<old_game_stat>();

    for (res in results) { 


        val ogs = old_game_stat(
            game_rowid = res.game_rowid.to_integer(),
            created_at = res.crt_at,
            // Opponent data
            opponent_name = res.opp_name,
            opponent_elo = res.opp_elo,
            // My data
            new_elo_rating = res.new_elo,
            // Neutral
            is_winner = res.winner,
            is_draw = res.draw,
            is_timeout = res.timeout,
            is_error = res.error
        );

        return_list.add(ogs);
    }
    
    return return_list;
}



// -------------------------------------
// Get opponent's (recent) actions
// 
// This is a heavy query, since we want to fetch everything that has happened 
// since the last seen turn. This means:
// 
// 1. Opponent's played card (if any),
// 2. Opponent's move,
// 3. Neutral move (usually "null" but could be double mave).
// 
// If the opponent only played a card, this will return a struct with only the card data,
// and the client has to keep calling this query while waiting for the opponent to make a move.
// 
// See documentation for [opponents_actions_result] for more details how to read the data.
// 
// Note on performance:
// To speed things up, we want to return everything the client needs in one single query.
// This way, the lag between turns can be kept to a minimum.
// -------------------------------------
query get_opponents_recent_actions (
    player_signer: pubkey,  // Player sends their own pubkey (Needed to know who is "me" and who is "opponent" for this game).
    game_id: integer,       // What game are we looking at? Cannot assume the game is "unfinished".
    last_seen_turn: integer // This is mostly a performance thing. We enforce that the client keeps track of what turn-number it has seen/fetched.
                            // If the client sends the correct [last_seen_turn] and nothing has happened since then, 
                            // the node should only have to do one single SELECT to the DB, then return "null".
): color_rotation_actions? {

    // Get the player's current game
    val minimal_game: minimal_game_result? = minimal_game_data_get_even_if_finished(player_signer, game_id);
    if (minimal_game == null) {
        log("game_id " + game_id + ", game not found, or not owned by the caller.");
        return null; 
    } 
    
    // Find the latest turn where it was the opponent's move
    // (This is the current turn if it's the opponent's turn, 
    // or the previous turn if it's the player's turn)
    val g = minimal_game.game;
    val curr_turn_nr = minimal_game.curr_turn_nr;
    if (curr_turn_nr == last_seen_turn) return null; // No new turns, quit.

    // We won't allow the caller to fetch his own moves this way, too expensive and likely a bug.
    val max_turn_nr_of_the_color_rotation = color_rotation_find_max_turn_nr(last_seen_turn);
    require(curr_turn_nr <= max_turn_nr_of_the_color_rotation, "game_id " + game_id + ". You provided last_seen_turn: " + 
        last_seen_turn + " which indicates that the maximum turn is " + max_turn_nr_of_the_color_rotation + 
        ". But the current turn_nr is " + curr_turn_nr + ". Did you forget to save a move?");
    
    // Get everything that happened since last seen turn
    return color_rotation_get_all_actions(game_id, minimal_game, last_seen_turn);
 
}





