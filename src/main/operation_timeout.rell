

// -------------------------------------
// Still Thinking
//
// If the player hasn't taken any action for 60 seconds, 
// the player should send this operation to show the node that 
// the player is still alive. If not the opponent can timeout 
// the game.
// (Don't forget to add a Nop() operation to the TX)
// -------------------------------------
operation still_thinking(game_id: integer) {

    val current_signers = op_context.get_signers();
    val current_signer = current_signers[0];

    val minimal_game: minimal_game_result? = minimal_game_data_get(current_signer);
    require (minimal_game != null, "Player is not in a game, id:" + game_id);
    require(minimal_game.game_id == game_id, "The game id of the ongoing game " + minimal_game.game_id + " doesn't match the given id " + game_id + ".");

    var color = "Black";
    if (minimal_game.is_white) {
        color = "White";
    }
    log("game_id: " + game_id + " - " + color + " still thinking.");
    game_timeout_set_player_alive(minimal_game.player_game);
}


// -------------------------------------
// Claim Timeout
// 
// If the player suspects that the opponent has timed out, 
// (s)he can call this operation.
//
// It will crash with error if the opponent has NOT timed out.
// -------------------------------------

operation claim_timeout(game_rowid: integer, random_seed: integer, seed_signature: byte_array) {
    
    val current_signers = op_context.get_signers();
    val caller_pubkey = current_signers[0];
    
    // Get the caller's player entity
    val caller_player = player@{.signer == caller_pubkey};

    // Get the player's current game
    //val estimated_time_left_ms = 0; // This way we force a real timeout calculation.
    val (maximal_game: maximal_game_result?, game_time: game_time_result?, opp_timeout_data: opponent_timeout_data?) =
        maximal_game_and_timeout_data_get(caller_pubkey);

    if (maximal_game == null) {
        // There is a chance that the opponent has ended the game already
        // Let's look again using the game_rowid.
        val res = game @? {.rowid == rowid(game_rowid)} (ended = .is_finished, end_reason = .finish_reason);
        require(res != null, "Game does not exist? game_id: " + game_rowid); // Error

        if (res.ended) {
            // Since we know that the game isn't ongoing, this is the message we expect to return to the client. 
            require(false, "The game has ended already as: " + res.end_reason.name + ", did the opponent end game " + game_rowid + "?");
        } else {
            // Error, should never happen
            require(false, "Internal error: didn't expect to find this game ongoing (already checked for that)?");
        }
    } else {
        // Another sanity check
        val game_id = maximal_game.game_id;
        require(game_id == game_rowid, "The game you sent " + game_rowid + " isn't the one one we found " + game_id + ".");

        // Timeout check
        val curr_time_ms: timestamp = op_context.last_block_time;
        val (abandon: boolean, has_timed_out: boolean) = timeout_calc_all(game_id, curr_time_ms, opp_timeout_data!!);
        require(abandon or has_timed_out, "The opponent has not timed out yet. Please don't waste our resources like this!");
        var end_reason: game_end_type = game_end_type.NOTHING;
        if (abandon) {
            log("game_id " + game_id + " - client claimed timeout, and opponent has indeed timed out due to inactivity.");
            end_reason = game_end_type.ABANDONED;
        } else if (has_timed_out) {
            log("game_id " + game_id + " - client claimed timeout, and opponent has indeed timed out due to total time.");
            end_reason = game_end_type.TIMEOUT;
        } else {
            log("game_id " + game_id + " - ERROR! What timout is this?"); // Cannot happen, we just checked for this.
        }

        // ... so no need setting the [current_turn_nr] here. 
        update maximal_game.game (
            .is_finished = true, 
            .is_finished_by_claim = true, 
            .finish_reason = end_reason);

        // Don't create [event_game_end], that's only when the game ends BECAUSE of a move.

        // As usual, we'll set ourself as winner, until the opponent provides their seed.
        game_over_first_inner_set_winner_and_loser_from_max_game(maximal_game, caller_pubkey, random_seed, seed_signature, end_reason);
    }
}