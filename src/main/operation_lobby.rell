


// -------------------------------------
// Lobby 
// -------------------------------------

operation enter_lobby(game_type_str: text) {

    val current_signers = op_context.get_signers();
    val current_signer = current_signers[0];
     
    val playa = player@ {.signer == current_signer};

    val g_type = game_type.value(game_type_str);

    val existing_lobby = lobby@? {.player == playa, .game_type == g_type};

    if (existing_lobby == null) {

        // Only terminate running games first time we enter the lobby
        game_terminate_if_old(playa);

        log("enter_lobby");
        create lobby(
        .player = playa,
        .game_type = g_type,
        .last_heartbeat = op_context.last_block_time
        );
    }
    else {
        update existing_lobby (.last_heartbeat = op_context.last_block_time);
    }
}


// Exit all lobby entries. 
// 
// This is when the player is kind enough to click the "stop waiting" button,
// instead of just shutting down the game.
operation exit_lobby() {

    val current_signers = op_context.get_signers();
    val current_signer = current_signers[0];
     
    val playa = player@ {.signer == current_signer};
    
    // Remove caller's lobby
    log("exit_lobby");
    delete lobby@* {.player == playa};
}

// -------------------------------------
// Game Creation
// -------------------------------------

// --------
// Via lobby
// --------

// Usually players find each other in the lobby
// Here we send the opponent player name and the game type
operation create_game_via_lobby_by_name(opp_player_name: text, game_type_str: text) {
    val opponent_player = player@{.name == opp_player_name};
    val new_game: game = game_create_via_lobby_inner(opponent_player, game_type_str);
    log("create_game_via_lobby_by_name() - finished, game: " + new_game.rowid.to_integer() + " type: " + game_type_str + " opp player: " + opp_player_name);
}

// Here we send the opponent player pubkey and the game type
operation create_game_via_lobby(opp_player: pubkey, game_type_str: text) {
    val opponent_player = player@{.signer == opp_player};
    val new_game: game = game_create_via_lobby_inner(opponent_player, game_type_str);
    log("create_game_via_lobby() - finished, game: " + new_game.rowid.to_integer() + " type: " + game_type_str);
}

// --------
// Direct
// --------

// Create a new game between two players
// Could be a challange
operation create_game(white_player_name: text, black_player_name: text, game_type_str: text) {
    require(white_player_name != black_player_name, "Players must be different");
    
    val white_player = player@{white_player_name};
    val black_player = player@{black_player_name};

    val new_game: game = game_create_inner(white_player, black_player, game_type_str);
    log("create_game() - finished, game: " + new_game.rowid.to_integer() + " type: " + game_type_str);
}






