
// -------------------------------------
// Games
// -------------------------------------
// Here the client can ask about if being in a game, 
// old games etc.
// -------------------------------------

// -------------------------------------
// In Game query
//
// Returns a hodge-podge of data about the game.
// -------------------------------------

query in_game (
   player_signer: pubkey // The player's own pubkey
) :in_game_result? {

    val minimal_game: minimal_game_result? = minimal_game_data_get(player_signer);

    if (minimal_game == null) {
        return null;
    } else {
        val g_data = game@ {.rowid == minimal_game.game.rowid} (.rowid, .black_player, .white_player, .seed_material, .created_at);


        val plays_white = minimal_game.is_white;
        var opp: player? = null;
 
        if (plays_white) {
            opp = g_data.black_player;
        } else {
            opp = g_data.white_player;
        }

        return in_game_result(
            game_rowid = g_data.rowid.to_integer(),
            game_type = minimal_game.game_type,
            is_white = plays_white,
            opponent_pubkey = opp.signer,
            opponent_name = opp.name,
            opponent_elo = opp.elo_rating,
            curr_turn_nr = minimal_game.curr_turn_nr,
            created_at = g_data.created_at,
            seed_material = g_data.seed_material
        );
    }
}

// -------------------------------------
// Get Game End query
//
// Returns a [game_end_data] object if the game-player combo exists.
// -------------------------------------

query get_game_end (
   player_signer: pubkey, // The player's own pubkey
   game_id: integer
) :game_end_data? {

    return game_end_data_get(player_signer, game_id);
}

// -------------------------------------
// Old games
//
// The player wants to see his/her of old games:
// a) who (s)he played against (elo, name),
// b) who won,
// c) what happened to the ELO rating.
// -------------------------------------
query get_old_games(
    player_signer: pubkey
): list<old_game_stat> {
    val results =  (p_my: player, pgs_my: player_game_stats)@* {
        p_my.signer == player_signer,
        pgs_my.player == p_my
    } (
        game_rowid = pgs_my.game.rowid, 
        @sort_desc crt_at = pgs_my.created_at,
        opp_name = pgs_my.opp_name,
        opp_elo = pgs_my.opp_elo,
        new_elo = pgs_my.new_elo_rating,
        winner = pgs_my.is_winner,
        draw = pgs_my.is_draw,
        end_reason = pgs_my.finish_reason
    ) limit 100;

    val return_list = list<old_game_stat>();

    for (res in results) { 


        val ogs = old_game_stat(
            game_rowid = res.game_rowid.to_integer(),
            created_at = res.crt_at,
            // Opponent data
            opponent_name = res.opp_name,
            opponent_elo = res.opp_elo,
            // My data
            new_elo_rating = res.new_elo,
            // Neutral
            is_winner = res.winner,
            is_draw = res.draw,
            finish_reason = res.end_reason.name
        );

        return_list.add(ogs);
    }
    
    return return_list;
}


// -------------------------------------
// Get ALL rotations for an old (=finished) game.
//
// We used compressed data to save some CPU. 
// -------------------------------------
query get_entire_old_game(
    game_id: integer
): entire_game_data  {

    log("game_id: " + game_id + " - Begin ");
   
    // ----------------------
    // 1. Find game end data
    // ----------------------
    val game_rowid = rowid(game_id);

    val res = (
        p_white: player, 
        pg_white: player_game, 
        g: game, 
        pg_black: player_game, 
        p_black: player 
    )@? {
        pg_white.player == p_white,
        pg_white.is_white == true, 
        pg_white.game == g,
        g.rowid == game_rowid, // <-- THE GAME WE ARE LOOKING FOR
        pg_black.game == g, // We need this to get the opponent's timeout data
        pg_black.is_white == false,
        pg_black.player == p_black
    } (gme = g, 
        white_p = p_white, black_p = p_black,  // Player
        white_pg = pg_white, black_pg = pg_black,  // P.G.
        white_name = p_white.name, black_name = p_black.name, // Names
        white_elo_before = pg_white.elo_rating_before_game, black_elo_before = pg_black.elo_rating_before_game, // initial ELO 
        // white_elo = p_white.elo_rating, black_elo = p_black.elo_rating, // curr ELO
        game_type = g.game_type, game_max_turns = g.current_turn_nr, game_max_rotations = g.current_rotation_nr,
        game_finished = g.is_finished,  game_finish_reason = g.finish_reason, by_claim = g.is_finished_by_claim, i_claimed_end = pg_white.claimed_end, // End data
        game_valid_seeds = g.valid_seeds_count, game_invalid_seeds = g.invalid_seeds_count // End data
        );

    require(res != null, "Game not found, game_id: " + game_id);


    // Primary keys
    val white_p = res.white_p;
    val white_pg = res.white_pg;
    val black_p = res.black_p;
    val black_pg = res.black_pg;
    val gme = res.gme;

    val g_type = res.game_type.name;
    val g_max_turns = res.game_max_turns; // The turn when the game ended (given it's over)
    val g_max_rotations = res.game_max_rotations; // The rotation when the game ended (given it's over)


    val g_end_data = game_end_data(
        is_finished = res.game_finished,
        is_finished_by_claim = res.by_claim,
        is_my_claim = res.i_claimed_end, // "I" will have to mean "white" here, not a perfect match.
        finish_reason = res.game_finish_reason.name,
        valid_seeds_count = res.game_valid_seeds,
        invalid_seeds_count = res.game_invalid_seeds
    );

    // ----------------------
    // 2. Find the rotations
    // ----------------------
    val rot_list = player_rotation_compressed_get_all(game_id, gme, g_max_rotations);

    // ----------------------
    // 3. Return 
    // ----------------------
    
    val ret = entire_game_data(
        // 1.
        game_type_str = g_type,
        white_name = res.white_name,
        black_name = res.black_name,
        white_elo_before_game = res.white_elo_before,
        black_elo_before_game = res.black_elo_before,
        // 2.
        rotations = rot_list,
        // 3.
        game_end_data = g_end_data
    );

    log("game_id: " + game_id + " - End: " + ret.white_name + " vs " + ret.black_name);
    return ret;
}

